if(method=="lmm"){
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste0("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=substitute(id), small.samp.method=small.samp.method, ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_lp"){
## Make sure random effects are factor
random=paste("(", lme4::findbars(form_sub), ")")
random<-sapply(random, function(x) gsub(" ", "", stringr::str_split(stringr::str_split(x, pattern = "\\)")[[1]], "\\|")[[1]][2]))
if(sum(sapply(random, function(x) class(sample_data[,x])!="factor"))>0) stop("All grouping variables in random effects must be factors")
args<-list(formula=form_sub, data=quote(dat_sub), #random=random,
family = "nbinom",...)
method_call=glmmADMB::glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}else if(method=="nbmm_agq"){
## Separate random and fixed effects
random=paste0(lme4::findbars(form_sub), collapse = "+")
fixed_eff=lme4::nobars(form_sub)
args=args2=list(fixed=fixed_eff, random=random, data=quote(dat_sub),
family=GLMMadaptive::negative.binomial(), ...)
args2$family=poisson()
method_call=GLMMadaptive::mixed_model
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = F,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
}
names(ret)<-gene_names
return(ret)
}
fit=corrSeq_fit(~group*time+offset(log_offset)+(1|patient), expr_mat=counts[1:5,], sample_data = sample_data,
#parallel = T, cores = 8,
method="nbmm_agq")
i=1
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
do.call(method_call, args)
method_call
args
do.call(method_call, args)
form_sub
aste0(lme4::findbars(form_sub), collapse = "+")
paste0(lme4::findbars(form_sub), collapse = "+")
paste0("~",lme4::findbars(form_sub), collapse = "+")
## Separate random and fixed effects
random=as.formula(paste0("~",paste0(lme4::findbars(form_sub), collapse = "+")))
corrSeq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
offset=NULL,
small.samp.method=NULL,
parallel = F,
cores = 2,
...
){
browser()
if(method=="lmm"){
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste0("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=substitute(id), small.samp.method=small.samp.method, ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_lp"){
## Make sure random effects are factor
random=paste("(", lme4::findbars(form_sub), ")")
random<-sapply(random, function(x) gsub(" ", "", stringr::str_split(stringr::str_split(x, pattern = "\\)")[[1]], "\\|")[[1]][2]))
if(sum(sapply(random, function(x) class(sample_data[,x])!="factor"))>0) stop("All grouping variables in random effects must be factors")
args<-list(formula=form_sub, data=quote(dat_sub), #random=random,
family = "nbinom",...)
method_call=glmmADMB::glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}else if(method=="nbmm_agq"){
## Separate random and fixed effects
random=as.formula(paste0("~",paste0(lme4::findbars(form_sub), collapse = "+")))
fixed_eff=lme4::nobars(form_sub)
args=args2=list(fixed=fixed_eff, random=random, data=quote(dat_sub),
family=GLMMadaptive::negative.binomial(), ...)
args2$family=poisson()
method_call=GLMMadaptive::mixed_model
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = F,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
}
names(ret)<-gene_names
return(ret)
}
fit=corrSeq_fit(~group*time+offset(log_offset)+(1|patient), expr_mat=counts[1:5,], sample_data = sample_data,
#parallel = T, cores = 8,
method="nbmm_agq")
View(fit)
fit_c3=corrSeq_fit(~time2+offset(log_offset)+(1|patient), expr_mat=counts[1:5,], sample_data = sample_data,
#parallel = T, cores = 8,
method="nbmm_adq")
View(fit_c3)
fit_c3=corrSeq_fit(~time2+offset(log_offset)+(1|patient), expr_mat=counts[1:5,], sample_data = sample_data,
#parallel = T, cores = 8,
method="nbmm_agq")
View(fit_c3)
fit2=fit_c3
all_dat=lapply(1:length(fit), function(y){
df=tryCatch({
my_aov=GLMMadaptive::anova(fit[[y]], fit2[[y]])
df=data.frame(LRT=my_aov$LRT, df=my_aov$df, p_val_raw=my_aov$p.value)
df
},error=function(e){
data.frame(LRT=NA, df=NA, p_val_raw=NA)
})
})%>%dplyr::bind_rows()
all_dat$p_val_adj=p.adjust(all_dat$p_val_raw, method = "BH")
all_dat$de=de
View(all_dat)
class(fit$gene_1)
library(corrRNASeq)
?corrSeq_fit
library(corrRNASeq)
?corrSeq_fit
devtools::build()
devtools::build()
library(corrRNASeq)
?corrSeq_fit
library(corrRNASeq)
?corrSeq_summary
devtools::document()
library(corrRNASeq)
?corrSeq_fit
?corrSeq_summary
load("C:/Users/ewynn/Repositories/corrRNASeq/data/simdata.RData")
View(simdata)
View(simdata[["metadata"]])
load("C:/Users/ewynn/Repositories/corrRNASeq/data/simdata.RData")
load("C:/Users/ewynn/Repositories/corrRNASeq/data/simdata.RData")
devtools::document()
library(corrRNASeq)
library(corrRNASeq)
library(DESeq2)
library(rmRNAseq)
library(edgeR)
library(GLMMadaptive)
sim_data <- readRDS("C:/Users/ewynn/Repositories/long_rnaseq_rnd2/sim_data/sim_data_FDR_n3_4x_1.RDS")
c(303, 2447, 2706, 4001, 5358, 11547, 12748, 13437, 13812)
rm_idx=c(303, 2447, 2706, 4001, 5358, 11547, 12748, 13437, 13812)
sim_data$counts=sim_data$counts[-rm_idx,]
View(sim_data)
counts <- as.matrix(sim_data$counts)
sample_data=data.frame(patient=factor(sim_data$ids, levels=unique(sim_data$ids)),
time=factor(sim_data$time),
group=factor(sim_data$groups))
de=sim_data$param[,"beta_ints"]!=0
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = sample_data,
design = ~ group*time)
dds = estimateSizeFactors(dds)
sample_data$log_offset <- log(sizeFactors(dds))
sample_data$id=sample_data$patient
corrSeq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
offset=NULL,
small.samp.method=NULL,
parallel = F,
cores = 2,
...
){
if(method=="lmm"){
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste0("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=substitute(id), small.samp.method=small.samp.method, ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_lp"){
## Make sure random effects are factor
random=paste("(", lme4::findbars(form_sub), ")")
random<-sapply(random, function(x) gsub(" ", "", stringr::str_split(stringr::str_split(x, pattern = "\\)")[[1]], "\\|")[[1]][2]))
if(sum(sapply(random, function(x) class(sample_data[,x])!="factor"))>0) stop("All grouping variables in random effects must be factors")
args<-list(formula=form_sub, data=quote(dat_sub), #random=random,
family = "nbinom",...)
method_call=glmmADMB::glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}else if(method=="nbmm_agq"){
## Separate random and fixed effects
random=as.formula(paste0("~",paste0(lme4::findbars(form_sub), collapse = "+")))
fixed_eff=lme4::nobars(form_sub)
args=args2=list(fixed=fixed_eff, random=random, data=quote(dat_sub),
family=GLMMadaptive::negative.binomial(), ...)
args2$family=poisson()
method_call=GLMMadaptive::mixed_model
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
print(i)
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = F,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
if(method=="nbmm_agq"){
#If error, try fitting with a poisson model
ret_sub2  <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args2)))
}, error=function(e){NULL})
}else ret_sub2 <- NULL
ret_sub2
})
ret2 <- ret_sub
if(method=="nbmm_lp"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
}
names(ret)<-gene_names
return(ret)
}
fit=corrSeq_fit(~group*time+offset(log_offset), expr_mat=counts[304:nrow(counts),], sample_data = sample_data,
#                parallel = T, cores = 8,
method="gee",  id=id, small.samp.method = "wl")
#########################
## Save Data for package
#########################
library(DESeq2)
simdata=readRDS("sim_data/sim_data_FDR_n3_4x_1.RDS")
## Counts
counts=simdata$counts
rm_idx=c(303, 2447, 2706, 4001, 5358, 11547, 12748, 13437, 13812)
counts=counts[-rm_idx,]
## Metadata
metadata=data.frame(patient=factor(simdata$ids, levels=unique(simdata$ids)),
time=factor(simdata$time),
group=factor(simdata$groups))
## DE
de=simdata$param[,"beta_ints"]!=0
de=de[-rm_idx]
## Get VST
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = metadata,
design = ~ group*time)
vsd.fixed <- varianceStabilizingTransformation(dds, blind=F)
vst<- assay(vsd.fixed)
## Get offset
dds = estimateSizeFactors(dds)
metadata$log_offset <- log(sizeFactors(dds))
simdata=list(counts=counts, metadata=metadata, vst_expr=vst, de=de)
save(simdata, file="../corrRNASeq/data/simdata.RData")
#########################
## Save Data for package
#########################
library(DESeq2)
simdata=readRDS("sim_data/sim_data_FDR_n3_4x_1.RDS")
simdata=readRDS("../long_rnaseq_rnd2/sim_data/sim_data_FDR_n3_4x_1.RDS")
## Counts
counts=simdata$counts
rm_idx=c(303, 2447, 2706, 4001, 5358, 11547, 12748, 13437, 13812)
counts=counts[-rm_idx,]
## Metadata
metadata=data.frame(patient=factor(simdata$ids, levels=unique(simdata$ids)),
time=factor(simdata$time),
group=factor(simdata$groups))
## DE
de=simdata$param[,"beta_ints"]!=0
de=de[-rm_idx]
## Get VST
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = metadata,
design = ~ group*time)
vsd.fixed <- varianceStabilizingTransformation(dds, blind=F)
vst<- assay(vsd.fixed)
## Get offset
dds = estimateSizeFactors(dds)
metadata$log_offset <- log(sizeFactors(dds))
simdata=list(counts=counts, metadata=metadata, vst_expr=vst, de=de)
save(simdata, file="../corrRNASeq/data/simdata.RData")
devtools::document()
devtools::document()
library(corrRNASeq)
