}else if(small.samp.method=="md"){
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xx <- t(D) %*% solve(Vi) %*% D
step11 <- step11 + xx
}
}else if(small.samp.method=="wl"){
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
xx <- t(covariate) %*% solve(var_i) %*% covariate
step01 <- step01 + xx
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xx <- t(D) %*% solve(Vi) %*% D
step01 <- step01 + xx
}
}
}
if(small.samp.method=="wl"){
step <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
for (i in 1:size) {
y <- as.matrix(data$response[data$id == unique(data$id)[i]])
covariate <- as.matrix(subset(mat[, -length(mat[1, ])],
mat$subj == unique(data$id)[i]))
#EAW added fitted values so don't have to solve using link
mu=as.matrix(gee.fit$fitted.values[data$id == unique(data$id)[i]])
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
resid <- solve(cormax.ind(cluster$n[i]) - covariate %*%
solve(step01) %*% t(covariate) %*% solve(var_i)) %*%
(y - mu)
step <- step + resid %*% t(resid)
}
else if (family == "poisson") {
B <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(B) <- 1/sqrt(mu)
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
resid <- B %*% solve(cormax.ind(cluster$n[i]) - D %*%
solve(step01) %*% t(D) %*% solve(Vi)) %*% (y -mu)
step <- step + resid %*% t(resid)
}
}
}
if(small.samp.method%in% c("pan", "wl")){
unstr <- step/size
step11 <- matrix(0, nrow = len, ncol = len)
}
step12 <- matrix(0, nrow = len, ncol = len)
step13 <- matrix(0, nrow = len_vec, ncol = 1)
step14 <- matrix(0, nrow = len_vec, ncol = len_vec)
p <- matrix(0, nrow = len_vec, ncol = size)
for (i in 1:size) {
y <- as.matrix(data$response[data$id == unique(data$id)[i]])
covariate <- as.matrix(subset(mat[, -length(mat[1, ])],
mat$subj == unique(data$id)[i]))
#EAW added fitted values so don't have to solve using link
mu=as.matrix(gee.fit$fitted.values[data$id == unique(data$id)[i]])
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if(small.samp.method=="pan"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% unstr %*%
solve(var) %*% covariate
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
else if (family == "poisson") {
A <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(A) <- mu
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% sqrt(A) %*% unstr %*%
sqrt(A) %*% solve(Vi) %*% D
xx <- t(D) %*% solve(Vi) %*% D
step12 <- step12 + xy
step11 <- step11 + xx
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
}else if(small.samp.method=="md"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% solve(cormax.ind(cluster$n[i]) -
covariate %*% solve(step11) %*% t(covariate) %*%
solve(var_i)) %*% (y - mu)
step12 <- step12 + xy %*% t(xy)
step13 <- step13 + matrixcalc::vec(xy %*% t(xy))
p[, i] <- matrixcalc::vec(xy %*% t(xy))
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% solve(cormax.ind(cluster$n[i]) -
D %*% solve(step11) %*% t(D) %*% solve(Vi)) %*%
(y - mu)
step12 <- step12 + xy %*% t(xy)
step13 <- step13 + matrixcalc::vec(xy %*% t(xy))
p[, i] <- matrixcalc::vec(xy %*% t(xy))
}
}else if(small.samp.method=="wl"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% unstr %*%
solve(var) %*% covariate
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
else if (family == "poisson") {
B <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(B) <- mu
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% sqrt(B) %*% unstr %*%
sqrt(B) %*% solve(Vi) %*% D
xx <- t(D) %*% solve(Vi) %*% D
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
}
}
for (i in 1:size) {
dif <- (p[, i] - step13/size) %*% t(p[, i] - step13/size)
step14 <- step14 + dif
}
cov.beta <- solve(step11) %*% (step12) %*% solve(step11)
cov.var <- size/(size - 1) * kronecker(solve(step11), solve(step11)) %*%
step14 %*% kronecker(solve(step11), solve(step11))
gee.fit$small.samp.var<-diag(cov.beta)
gee.fit$call<-call
return(gee.fit)
}
geeglm.small.samp(form, ids, data=dat, family=poisson, corstr="exchangeable", small.samp.method = "pan")
call
geeglm.small.samp<-function (formula, id, family = gaussian, data,
corstr = "independence", small.samp.method, sort=T, ...)
{
call <- match.call(expand.dots = TRUE)
if (is.null(data$id)) {
index <- which(names(data) == id)
data$id <- data[, index]
}
init <- model.frame(formula, data)
init$num <- 1:length(init[, 1])
if (any(is.na(init))) {
index <- na.omit(init)$num
data <- data[index, ]
m <- model.frame(formula, data)
mt <- attr(m, "terms")
data$response <- model.response(m, "numeric")
mat <- as.data.frame(model.matrix(formula, m))
}
else {
m <- model.frame(formula, data)
mt <- attr(m, "terms")
data$response <- model.response(m, "numeric")
mat <- as.data.frame(model.matrix(formula, m))
}
#################Make sure data is sorted################
if(sort) {
data<-data[order(data[[paste(call$id)]]),]
call$data=quote(data)
}
###Use geepack model (geesmv fits "gee" package model)###
#Calling geeglm
call_list<-as.list(call)
call_list[[1]]<-call_list$small.samp.method<-call_list$sort<-NULL
gee.fit<-do.call("geeglm", call_list)
beta_est <- gee.fit$coefficients
alpha <- summary(gee.fit)$corr[[1]]
#########Drawing largely from code from geesmv package############
len <- length(beta_est)
len_vec <- len^2
data$id <- as.numeric(gee.fit$id)
cluster <- cluster.size(data$id)
ncluster <- max(cluster$n)
size <- cluster$m
mat$subj <- rep(unique(data$id), cluster$n)
if (is.character(corstr)) {
var <- switch(corstr, independence = cormax.ind(ncluster),
exchangeable = cormax.exch(ncluster, alpha), `AR-M` = cormax.ar1(ncluster,
alpha), unstructured = summary(gee.fit)$working.correlation
)
}
else {
print(corstr)
stop("'working correlation structure' not recognized")
}
if (is.character(family)) {
family <- switch(family, gaussian = "gaussian",
poisson = "poisson")
}
else {
if (is.function(family)) {
family <- family()[[1]]
}
else {
print(family)
stop("'family' not recognized")
}
}
if(small.samp.method=="wl"){
m <- model.frame(formula, data)
mat <- as.data.frame(model.matrix(formula, m))
mat$subj <- rep(unique(data$id), cluster$n)
}
cov.beta <- unstr <- matrix(0, nrow = len, ncol = len)
if(small.samp.method=="pan") step <- matrix(0, nrow = cluster$n[1], ncol = cluster$n[1])
else if(small.samp.method=="md") step11 <- matrix(0, nrow = len, ncol = len)
else if(small.samp.method=="wl")step01 <- matrix(0, nrow = len, ncol = len)
for (i in 1:size) {
y <- as.matrix(data$response[data$id == unique(data$id)[i]])
covariate <- as.matrix(subset(mat[, -length(mat[1, ])],
mat$subj == unique(data$id)[i]))
#EAW added fitted values so don't have to solve using link
mu=as.matrix(gee.fit$fitted.values[data$id == unique(data$id)[i]])
if(small.samp.method=="pan"){
if (family == "gaussian") {
resid <- (y - mu) %*% t(y - mu)
step <- step + resid
}
else if (family == "poisson") {
resid <- (y - mu) %*% t(y -
mu)
B <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(B) <- 1/sqrt(mu)
step <- step + B %*% resid %*% B
}
}else if(small.samp.method=="md"){
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xx <- t(D) %*% solve(Vi) %*% D
step11 <- step11 + xx
}
}else if(small.samp.method=="wl"){
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
xx <- t(covariate) %*% solve(var_i) %*% covariate
step01 <- step01 + xx
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xx <- t(D) %*% solve(Vi) %*% D
step01 <- step01 + xx
}
}
}
if(small.samp.method=="wl"){
step <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
for (i in 1:size) {
y <- as.matrix(data$response[data$id == unique(data$id)[i]])
covariate <- as.matrix(subset(mat[, -length(mat[1, ])],
mat$subj == unique(data$id)[i]))
#EAW added fitted values so don't have to solve using link
mu=as.matrix(gee.fit$fitted.values[data$id == unique(data$id)[i]])
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if (family == "gaussian") {
resid <- solve(cormax.ind(cluster$n[i]) - covariate %*%
solve(step01) %*% t(covariate) %*% solve(var_i)) %*%
(y - mu)
step <- step + resid %*% t(resid)
}
else if (family == "poisson") {
B <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(B) <- 1/sqrt(mu)
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
resid <- B %*% solve(cormax.ind(cluster$n[i]) - D %*%
solve(step01) %*% t(D) %*% solve(Vi)) %*% (y -mu)
step <- step + resid %*% t(resid)
}
}
}
if(small.samp.method%in% c("pan", "wl")){
unstr <- step/size
step11 <- matrix(0, nrow = len, ncol = len)
}
step12 <- matrix(0, nrow = len, ncol = len)
step13 <- matrix(0, nrow = len_vec, ncol = 1)
step14 <- matrix(0, nrow = len_vec, ncol = len_vec)
p <- matrix(0, nrow = len_vec, ncol = size)
for (i in 1:size) {
y <- as.matrix(data$response[data$id == unique(data$id)[i]])
covariate <- as.matrix(subset(mat[, -length(mat[1, ])],
mat$subj == unique(data$id)[i]))
#EAW added fitted values so don't have to solve using link
mu=as.matrix(gee.fit$fitted.values[data$id == unique(data$id)[i]])
var_i = var[1:cluster$n[i], 1:cluster$n[i]]
if(small.samp.method=="pan"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% unstr %*%
solve(var) %*% covariate
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
else if (family == "poisson") {
A <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(A) <- mu
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% sqrt(A) %*% unstr %*%
sqrt(A) %*% solve(Vi) %*% D
xx <- t(D) %*% solve(Vi) %*% D
step12 <- step12 + xy
step11 <- step11 + xx
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
}else if(small.samp.method=="md"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% solve(cormax.ind(cluster$n[i]) -
covariate %*% solve(step11) %*% t(covariate) %*%
solve(var_i)) %*% (y - mu)
step12 <- step12 + xy %*% t(xy)
step13 <- step13 + matrixcalc::vec(xy %*% t(xy))
p[, i] <- matrixcalc::vec(xy %*% t(xy))
}
else if (family == "poisson") {
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% solve(cormax.ind(cluster$n[i]) -
D %*% solve(step11) %*% t(D) %*% solve(Vi)) %*%
(y - mu)
step12 <- step12 + xy %*% t(xy)
step13 <- step13 + matrixcalc::vec(xy %*% t(xy))
p[, i] <- matrixcalc::vec(xy %*% t(xy))
}
}else if(small.samp.method=="wl"){
if (family == "gaussian") {
xy <- t(covariate) %*% solve(var_i) %*% unstr %*%
solve(var) %*% covariate
xx <- t(covariate) %*% solve(var_i) %*% covariate
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
else if (family == "poisson") {
B <- matrix(0, nrow = cluster$n[i], ncol = cluster$n[i])
diag(B) <- mu
D <- mat.prod(covariate, mu)
Vi <- diag(sqrt(c(mu)),
cluster$n[i]) %*% var_i %*% diag(sqrt(c(mu)), cluster$n[i])
xy <- t(D) %*% solve(Vi) %*% sqrt(B) %*% unstr %*%
sqrt(B) %*% solve(Vi) %*% D
xx <- t(D) %*% solve(Vi) %*% D
step11 <- step11 + xx
step12 <- step12 + xy
step13 <- step13 + matrixcalc::vec(xy)
p[, i] <- matrixcalc::vec(xy)
}
}
}
for (i in 1:size) {
dif <- (p[, i] - step13/size) %*% t(p[, i] - step13/size)
step14 <- step14 + dif
}
cov.beta <- solve(step11) %*% (step12) %*% solve(step11)
cov.var <- size/(size - 1) * kronecker(solve(step11), solve(step11)) %*%
step14 %*% kronecker(solve(step11), solve(step11))
gee.fit$small.samp.var<-diag(cov.beta)
gee.fit$call<-call
return(gee.fit)
}
geeglm.small.samp(form, ids, data=dat, family=poisson, corstr="exchangeable", small.samp.method = "pan")
geeglm.small.samp(form, ids, data=dat, family=poisson, corstr="exchangeable", small.samp.method = "pan", sort=F)
?glm
?lmer
?family
?geepack
?geeglm
?glm
?geesmv
?GEE.var.pan
?glm
?geepack
?geeglm
?GEE.var.pan
?lmer
setwd("C:/Users/wynne/Repositories/corrRNASeq")
?glmm_nb_lmer
?lmer
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::document()
library(corrRNASeq)
?geeglm_small_samp
data("simdata")
sample_meta_data <- simdata$metadata
#Subset down to one observation (i.e. gene)
counts=simdata$counts[1,]
#Combine counts, metadata into dataframe
df=cbind(counts, sample_meta_data)
##  Fit the Model-use Pan method for small sample variance
fit.gee.pan<-geeglm_small_samp(formula =counts ~ group * time,
family=poisson, data=df, id=ids, corstr="exchangeable", small.samp.method="pan", sort=T )
devtools::document()
devtools::document()
library(corrRNASeq)
?geeglm_small_samp
data("simdata")
sample_meta_data <- simdata$metadata
#Subset down to one observation (i.e. gene)
counts=simdata$counts[1,]
#Combine counts, metadata into dataframe
df=cbind(counts, sample_meta_data)
#Fit the Model-use Pan method for small sample variance
fit.gee.pan<-geeglm_small_samp(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable",
small.samp.method="pan", sort=T )
fit.gee.pan
test<-geeglm(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable")
library(geepack)
test<-geeglm(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable")
test
df$ids
devtools::document()
library(corrRNASeq)
?geeglm_small_samp
data("simdata")
sample_meta_data <- simdata$metadata
#Subset down to one observation (i.e. gene)
counts=simdata$counts[1,]
#Combine counts, metadata into dataframe
df=cbind(counts, sample_meta_data)
#Sort data by id (Function also does this if sort=T)
df=df[order(df$ids),]
#Fit the Model-use Pan method for small sample variance
fit.gee.pan<-geeglm_small_samp(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable",
small.samp.method="pan", sort=T )
library(geepack)
test<-geeglm(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable")
test
fit.gee.pan
fit.gee.pan$small.samp.var
names(fit.gee.pan$small.samp.var)
names(fit.gee.pan$coefficients
0
names(fit.gee.pan$coefficients)
devtools::document()
library(corrRNASeq)
fit.gee.pan<-geeglm_small_samp(formula =counts ~ group * time,
family=poisson, data=df, id=ids,
corstr="exchangeable",
small.samp.method="pan", sort=T )
fit.gee.pan$small.samp
fit.gee.pan$small.samp.var
devtools::document()
load("C:/Users/wynne/Repositories/corrRNASeq/data/simdata.RData")
View(simdata)
simdata[["counts"]]
?lmer
devtools::document()
library(corrRNASeq)
?lmer
?geeglm_small_samp
?geeglm_small_samp
?get_SigmaG.glmm_nb_mod
library(NBZIMM)
?lmermodLmerTest
?lmerModLmerTest
?glmm.nb
devtools::document()
