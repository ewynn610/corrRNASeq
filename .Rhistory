design = ~ group + time + group_time)
dds <- DESeq(dds#, parallel = T
)
vsd.fixed <- varianceStabilizingTransformation(dds, blind=F)
vst_expr<- assay(vsd.fixed)
simdata2<-list(metadata=metadata, counts=counts, vst_expr=vst_expr,
de=de)
save(simdata2, file="data/simdata.RData")
dim(simdata2$counts)
devtools::document()
devtools::document()
library(corrRNASeq)
devtools::document()
data(simdata)
simdata=simdata2
save(simdata, file="data/simdata.RData")
devtools::document()
library(corrRNASeq)
# Load the library
library(corrRNASeq)
# Load the data
data("simdata")
names(simdata)
# metadata has information about the the study design
# each row is a sample and corresponds to a column
# in the expression matrix (counts)
sample_meta_data <- simdata$metadata
sample_meta_data
# The expression matrix (counts) has the same number of columns as
# rows in metadata.  The columns of the counts matrix
# are in the same order as the rows of the metadata.
# Subset to include 100 genes
counts <- simdata$counts[1:100,]
head(counts)
# The vst_expr object is the transformed expression matrix
# It was created using the vst function from DESeq2
# We will use this transformed data for the LMM method
# Subset to contain 100 genes
vst_expr<-simdata$vst_expr[1:100,]
head(vst_expr)
#########  Fit the Models for each method ###############
## GEE models using Wang-Long small sample size estimator
## log(library size) as an offset to adjust for sequencing depth
gee_fit <- corrSeq_fit(formula = ~ group * time+offset(log(lib_size)),
expr_mat = counts,
sample_data = sample_meta_data,
method="gee",
id=ids,
small.samp.method="wl")
## Fit NBMM-PL models
## Use log(library size) as an offset
nbmm_pl_fit <- corrSeq_fit(formula = ~ group *time+
offset(log(lib_size))+(1|ids),
expr_mat = counts,
sample_data = sample_meta_data,
method="nbmm_pl")
## Fit NBMM-ML models
## Random effects must be factors
## Use log(library size) as an offset
sample_meta_data$ids<-factor(sample_meta_data$ids)
View(gee_fit)
View(counts)
View(sample_meta_data)
?geeglm_small_samp
data("simdata")
sample_meta_data <- simdata$metadata
#Subset down to one observation (i.e. gene)
counts=simdata$counts[1,]
#Combine counts, metadata into dataframe
df=cbind(counts, sample_meta_data)
#Sort data by id (Function also does this if sort=T)
df=df[order(df$ids),]
View(df)
colnames(simdata$metadata)
colnames(simdata$metadata)[1]
colnames(simdata$metadata)[1]<-"ids"
save(simdata, "data/simdata.RData")
save(simdata, file="data/simdata.RData")
rm(simdata)
devtools::document()
library(corrRNASeq)
devtools::document()
library(corrRNASeq)
remove.packages("corrRNASeq", lib="~/R/R-4.0.3/library")
remove.packages("devtools", lib="~/R/R-4.0.3/library")
detach("package:lmerSeq", unload = TRUE)
remove.packages("lmerSeq", lib="~/R/R-4.0.3/library")
remove.packages("glmmADMB", lib="~/R/R-4.0.3/library")
install.packages(pkgs = c('devtools'))
devtools::install_github("stop-pre16/lmerSeq", build_vignettes = T)
devtools::install_github("stop-pre16/lmerSeq", build_vignettes = T)
install.packages("R2admb") install.packages("glmmADMB", repos=c("http://glmmadmb.r-forge.r-project.org/repos", getOption("repos")), type="source")
install.packages("R2admb")
install.packages("glmmADMB", repos=c("http://glmmadmb.r-forge.r-project.org/repos", getOption("repos")), type="source")
devtools::install_github("ewynn610/corrRNASeq", build_vignettes = T)
vignette("corrRNASeq::corrRNASeq-vignette")
vignette("corrRNASeq-vignette")
library(corrRNASeq)
?corrSeq_fit
devtools::document()
library(corrRNASeq)
devtools::document()
devtools::document()
library(corrRNASeq)
nbmm_ml_small <- readRDS("C:/Users/wynne/Repositories/dissertation/results_sim/tcells/nbmm_ml_small.RDS")
test<-corrRNASeq::corrSeq_summary(nbmm_ml_small, coef="grouptrt")
library(corrRNASeq)
test<-corrRNASeq::corrSeq_summary(nbmm_ml_small, coef="grouptrt")
head(test$summary_table)
View(test)
sum(is.na(test$summary_table$p_val_adj))
sim_nc50_ns10_de_1 <- readRDS("C:/Users/wynne/Repositories/dissertation/simulations/tcells/nc_50_de/sim_nc50_ns10_de_1.RDS")
View(nbmm_ml_small)
View(test)
View(test[["summary_table"]])
#' Function to fit various types of models to longitudinal RNA-Seq data
#'
#' Wrapper function that fits one of four types of models to RNA-Seq data. Available model fitting methods are linear mixed models (lmm) (using transformed data), generalized estimating equations with an optional small sample adjustment (gee), and negative binomial models using either
#' a pseudo-likelhood approach (nbmm_pl) or a maximum likelihood approach (nbmm_ml).
#'
#' @param formula A one-sided linear formula describing the model effects of the model. For \code{method="lmm"}, \code{method="nbmm_pl"} and \code{method="nbmm_ml"}, random effects should be included in the formula using the syntax of the lme4 package.
#' @param expr_mat A (G x N) numeric matrix RNA-seq expression data with genes in rows and samples in columns. For \code{method="gee"}, \code{method="nbmm_pl"} and \code{method="nbmm_ml"}, the matrix should contain raw counts and for \code{method="lmm"} the matrix should contain transformed counts (e.g. using VST from DESeq2). G = number of genes.  N = number of samples.
#' @param gene_names An optional character vector of gene names (length G).
#' @param sample_data Data frame with N rows containing the fixed- and random-effects terms included in the formula.  The rows of the data frame must correspond (and be in the same order as) the columns of the expression matrix.
#' @param method Method to use to fit the models. Possible options are \code{"lmm"}, \code{"gee"}, \code{"nbmm_pl"} and \code{"nbmm_ml"}.
#' @param parallel If on Mac or linux, use forking (via mclapply) to parallelize fits
#' @param id Only applicable for models fit using the \code{method="gee"} method. A vector or data column name which identifies the clusters. The length of
#' ‘id’ should be the same as the number of observations. Data are
#' assumed to be sorted so that observations on each cluster appear
#' as contiguous rows in data. If data is not sorted this way, the
#' function will not identify the clusters correctly. If \code{sort=TRUE} (default),
#' the dataframe from the \code{data} argument is sorted by the id column to avoid
#' this issue.
#' @param small.samp.method Only applicable for models fit using the \code{method="gee"} method. A character string specifying the
#' small sample method. The following are permitted: "pan" for the
#' Pan (2001) method, "md" for the Mancl and Derouen (2001) method, and "wl" for the Wang and Long (2011) method.
#' If \code{small.samp.method} is null, small sample variance estimates are not computed.
#' @param cores Number of cores to use (default is 2)
#' @param ... additional arguments passed on to \code{\link[lmerTest]{lmer}} (\code{method="lmm"}), \code{\link{gee_small_sample}}(\code{method="gee"}),
#' \code{\link{glmm_nb_lmer}} (\code{method="nbmm_pl"}) or \code{\link[glmmADMB]{glmmadmb}} (\code{method="nbmm_ml"})
#'
#' @return A list of length G of model objects from the following functions: \code{\link[lmerTest]{lmer}} (\code{method="lmm"}), \code{\link{gee_small_sample}}(\code{method="lmm"}),
#' \code{\link{glmm_nb_lmer}} (\code{method="nbmm_pl"}) or \code{\link[glmmADMB]{glmmadmb}} (\code{method="nbmm_ml"}).
#'
#'
#' @author Elizabeth Wynn
#'
#' @seealso \code{\link{corrSeq_summary}}, \code{\link{glmm_nb_lmer}}, \code{\link[lmerTest]{lmer}}, \code{\link{gee_small_sample}} and \code{\link[glmmADMB]{glmmadmb}}
#'
#' @examples
#' data("simdata")
#' sample_meta_data <- simdata$metadata
#'
#' ## Subset down to 10 observation (i.e. gene)
#' counts=simdata$counts[1:10,]
#'
#' ## Fit GEE models using Wang-Long small sample size estimator
#' ## Use log(library size) as an offset
#' gee_fit <- corrSeq_fit(formula = ~ group * time+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="gee",
#'                            id=ids,
#'                            small.samp.method="wl")
#'
#' ## Fit NBMM-PL models
#' ## Use log(library size) as an offset
#' nbmm_pl_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_pl")
#'
#' ## Fit NBMM-ML models
#' ## Random effects must be factors
#' ## Use log(library size) as an offset
#' sample_meta_data$ids<-factor(sample_meta_data$ids)
#' nbmm_ml_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_ml")
#'
#' ## Fit LMM models to transformed data
#' ## Use the variance transformed counts in the simdata object
#' ## Subset down to 10 genes
#' vst_expr<-simdata$simdata$vst_expr[1:10,]
#'
#' ##  Fit the Models
#' lmm_fit<- corrSeq_fit(formula = ~ group * time + (1|ids),
#'                            expr_mat = vst_expr,
#'                            sample_data = sample_meta_data,
#'                            method="lmm")
#' @export
#'
corrSeq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
small.samp.method=NULL,
parallel = F,
cores = 2, ...
){
if(method=="lmm"){
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste0("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=substitute(id), small.samp.method=small.samp.method, ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")
random<-sapply(random, function(x) gsub(" ", "", stringr::str_split(stringr::str_split(x, pattern = "\\)")[[1]], "\\|")[[1]][2]))
if(sum(sapply(random, function(x) class(sample_data[,x])!="factor"))>0) stop("All grouping variables in random effects must be factors")
args<-list(formula=form_sub, data=quote(dat_sub), #random=random,
family = "nbinom",...)
method_call=glmmADMB::glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- ret_sub
if(method=="nbmm_ml"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- ret_sub
if(method=="nbmm_ml"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
}
names(ret)<-gene_names
return(ret)
}
#' Function to fit various types of models to longitudinal RNA-Seq data
#'
#' Wrapper function that fits one of four types of models to RNA-Seq data. Available model fitting methods are linear mixed models (lmm) (using transformed data), generalized estimating equations with an optional small sample adjustment (gee), and negative binomial models using either
#' a pseudo-likelhood approach (nbmm_pl) or a maximum likelihood approach (nbmm_ml).
#'
#' @param formula A one-sided linear formula describing the model effects of the model. For \code{method="lmm"}, \code{method="nbmm_pl"} and \code{method="nbmm_ml"}, random effects should be included in the formula using the syntax of the lme4 package.
#' @param expr_mat A (G x N) numeric matrix RNA-seq expression data with genes in rows and samples in columns. For \code{method="gee"}, \code{method="nbmm_pl"} and \code{method="nbmm_ml"}, the matrix should contain raw counts and for \code{method="lmm"} the matrix should contain transformed counts (e.g. using VST from DESeq2). G = number of genes.  N = number of samples.
#' @param gene_names An optional character vector of gene names (length G).
#' @param sample_data Data frame with N rows containing the fixed- and random-effects terms included in the formula.  The rows of the data frame must correspond (and be in the same order as) the columns of the expression matrix.
#' @param method Method to use to fit the models. Possible options are \code{"lmm"}, \code{"gee"}, \code{"nbmm_pl"} and \code{"nbmm_ml"}.
#' @param parallel If on Mac or linux, use forking (via mclapply) to parallelize fits
#' @param id Only applicable for models fit using the \code{method="gee"} method. A vector or data column name which identifies the clusters. The length of
#' ‘id’ should be the same as the number of observations. Data are
#' assumed to be sorted so that observations on each cluster appear
#' as contiguous rows in data. If data is not sorted this way, the
#' function will not identify the clusters correctly. If \code{sort=TRUE} (default),
#' the dataframe from the \code{data} argument is sorted by the id column to avoid
#' this issue.
#' @param small.samp.method Only applicable for models fit using the \code{method="gee"} method. A character string specifying the
#' small sample method. The following are permitted: "pan" for the
#' Pan (2001) method, "md" for the Mancl and Derouen (2001) method, and "wl" for the Wang and Long (2011) method.
#' If \code{small.samp.method} is null, small sample variance estimates are not computed.
#' @param cores Number of cores to use (default is 2)
#' @param ... additional arguments passed on to \code{\link[lmerTest]{lmer}} (\code{method="lmm"}), \code{\link{gee_small_sample}}(\code{method="gee"}),
#' \code{\link{glmm_nb_lmer}} (\code{method="nbmm_pl"}) or \code{\link[glmmADMB]{glmmadmb}} (\code{method="nbmm_ml"})
#'
#' @return A list of length G of model objects from the following functions: \code{\link[lmerTest]{lmer}} (\code{method="lmm"}), \code{\link{gee_small_sample}}(\code{method="lmm"}),
#' \code{\link{glmm_nb_lmer}} (\code{method="nbmm_pl"}) or \code{\link[glmmADMB]{glmmadmb}} (\code{method="nbmm_ml"}).
#'
#'
#' @author Elizabeth Wynn
#'
#' @seealso \code{\link{corrSeq_summary}}, \code{\link{glmm_nb_lmer}}, \code{\link[lmerTest]{lmer}}, \code{\link{gee_small_sample}} and \code{\link[glmmADMB]{glmmadmb}}
#'
#' @examples
#' data("simdata")
#' sample_meta_data <- simdata$metadata
#'
#' ## Subset down to 10 observation (i.e. gene)
#' counts=simdata$counts[1:10,]
#'
#' ## Fit GEE models using Wang-Long small sample size estimator
#' ## Use log(library size) as an offset
#' gee_fit <- corrSeq_fit(formula = ~ group * time+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="gee",
#'                            id=ids,
#'                            small.samp.method="wl")
#'
#' ## Fit NBMM-PL models
#' ## Use log(library size) as an offset
#' nbmm_pl_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_pl")
#'
#' ## Fit NBMM-ML models
#' ## Random effects must be factors
#' ## Use log(library size) as an offset
#' sample_meta_data$ids<-factor(sample_meta_data$ids)
#' nbmm_ml_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_ml")
#'
#' ## Fit LMM models to transformed data
#' ## Use the variance transformed counts in the simdata object
#' ## Subset down to 10 genes
#' vst_expr<-simdata$simdata$vst_expr[1:10,]
#'
#' ##  Fit the Models
#' lmm_fit<- corrSeq_fit(formula = ~ group * time + (1|ids),
#'                            expr_mat = vst_expr,
#'                            sample_data = sample_meta_data,
#'                            method="lmm")
#' @export
#'
corrSeq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
small.samp.method=NULL,
parallel = F,
cores = 2, ...
){
browser()
if(method=="lmm"){
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-paste0("gene_", seq(1,nrow(expr_mat),1))}
gene_names =  rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=substitute(id), small.samp.method=small.samp.method, ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")
random<-sapply(random, function(x) gsub(" ", "", stringr::str_split(stringr::str_split(x, pattern = "\\)")[[1]], "\\|")[[1]][2]))
if(sum(sapply(random, function(x) class(sample_data[,x])!="factor"))>0) stop("All grouping variables in random effects must be factors")
args<-list(formula=form_sub, data=quote(dat_sub), #random=random,
family = "nbinom",...)
method_call=glmmADMB::glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- ret_sub
if(method=="nbmm_ml"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressWarnings(suppressMessages(do.call(method_call, args)))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- ret_sub
if(method=="nbmm_ml"&!is.null(ret2)) ret2$data=dat_sub
ret2
})
}
}
names(ret)<-gene_names
return(ret)
}
sim_dat<-sim_nc50_ns10_de_1
library(corrRNASeq)
library(dplyr)
library(DESeq2)
counts=sim_dat$counts%>%as.matrix()
meta=sim_dat$meta
method="nbmm_ml"
library(DESeq2)
#############Get DESeq offset#################
colData_in <- data.frame(group = meta$group)
dds <- DESeqDataSetFromMatrix(countData = counts,
colData = colData_in,
design = ~ group)
dds = estimateSizeFactors(dds)
meta$deseq_log_offset <- log(sizeFactors(dds))
meta$sample<-as.factor(meta$sample)
res<-corrSeq_fit(formula = ~group+offset(deseq_log_offset)+(1|sample),
expr_mat = counts,sample_data = meta, method = method)
res<-corrSeq_fit(formula = ~group+offset(deseq_log_offset)+(1|sample),
expr_mat = counts,sample_data = meta, method = method)
X=3
i=3
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
do.call(method_call, args)
test$singular_fits
length(test$singular_fits)
?lmerSeq.summary
devtools::document()
rm(corrSeq_fit)
devtools::document()
library(corrRNASeq)
devtools::document()
?lmerSeq.summary
devtools::document()
