}
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
if(!contrast_tf){
if(is.numeric(coefficient)){
if((coefficient > length(coef_names)) | coefficient < 1){
stop("Coefficient number is invalid")
}
coef_out <- coef_names[coefficient]
}else{
if(!(coefficient %in% coef_names)){
stop("Coefficient name is invalid")
}
coef_out <- coefficient
}
}
if(!(p_adj_method %in% p.adjust.methods)){
stop("Invalid p_adj_method")
}
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
if(df %in% c("Satterthwaite", "Kenward-Roger")){
ret <- do.call(rbind, lapply(corrSeq_results[idx_converged_not_singular], function(x){
# x = corrSeq_results$fitted_models[[1]]
if(!contrast_tf){
res_sub <- summary(x, ddf = df)$coefficients[coefficient, ]
names(res_sub)[names(res_sub)=="Pr(>|t|)"]<-"p_val_raw"
}else{
res_sub<-lmerTest::contest(x, contrast, ddf=df, joint=joint_flag)
names(res_sub)[names(res_sub)%in%c("Pr(>F)","Pr(>|t|)")]<-"p_val_raw"
}
return(res_sub)
}))%>%data.frame()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular],
p_val_adj = p.adjust(p_val_raw, method = p_adj_method))
if(joint_flag){
ret=ret%>%dplyr::select(Gene, Sum.Sq, Mean.Sq,NumDF, DenDF,F.value,
p_val_raw, p_val_adj)
}else{
ret=ret%>%dplyr::select(Gene, Estimate, Std.Error="Std..Error", "df","t.value",
p_val_raw, p_val_adj)
}
}else{
#If df will be same for all models, calculate now
constant_df_methods=c("residual", "containment")
if(df %in% constant_df_methods){
df=calc_df(model = corrSeq_results[[1]],df = df, method=method)
}
ret=lapply(corrSeq_results[idx_converged_not_singular], function(x){
#Estimate and std. error for gee
if(method=="gee"){
Estimate=x$coefficients[coefficient]
#if small sample method was used
if(!is.null(x$small.samp.va)){
Std.Error=sqrt(x$small.samp.var[coefficient])
}else Std.Error=summary(x)$coefficients[coefficient,"Std.err"]
}else if(method=="nbmm_pl"){
if(contrast_tf){
cont=lmerTest::contest(x, L=contrast, joint=F)$Estimate
Estimate=cont$Estimate
Std.Error=cont$`Std. Error`
}else{
Estimate=summary(x)$coefficients[coefficient,"Estimate"]
Std.Error=summary(x)$coefficients[coefficient,"Std. Error"]
}
}else if(method=="nbmm_ml"){
Estimate=summary(x)$coefficient[coefficient, "Estimate"]
Std.Error=summary(x)$coefficient[coefficient, "Std. Error"]
}
if(!is.numeric(df)){
df=calc_df(model=x, df=df, method=method)
}
t.value=Estimate/Std.Error
p_val_raw=2*pt(-abs(t.value),
df=df)
data.frame(Estimate=Estimate, Std.Error=Std.Error, df=df,
t.value=t.value, p_val_raw=p_val_raw)
})%>%dplyr::bind_rows()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular], p_val_adj=p.adjust(p_val_raw, method = p_adj_method))%>%
dplyr::select(Gene, Estimate, Std.Error, df, t.value, p_val_raw, p_val_adj)
}
rownames(ret) <- NULL
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
if(method !="gee"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
}
ret2$summary_table<-ret2$summary_table[match(gene_names,
ret2$summary_table$Gene),]
if(sort_results){
ret2$summary_table <- ret2$summary_table %>%
dplyr::arrange(p_val_adj)
}
ret2$model_method=method
ret2$df=df_name
rownames(ret2$summary_table)<-NULL
return(ret2)
}
########################################
#Calculate containment and residual df
########################################
calc_df<-function(model, df, method){
if(method=="lmm"|method=="nbmm_pl"|method=="nbmm_ml"){
#if nbmm_ml, fit lmm in order to get zmat and xmat
if(method=="nbmm_ml") model=lme4::lmer(formula = model$formula, data=model$data)
if(method=="lmm") model=model$fit
ids<-names(ranef(model))
#Mistake-not arequirement to have same number of measurements for each subject
#if(length(unique(table(model@frame[,ids])))!=1) stop("Must have the same number of measurements for each subject")
x_mat=matrix(getME(model, "X"), ncol =ncol(getME(model, "X")))
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(x_mat)-x_rank
}else if(df=="containment"){
z_mat<-matrix(getME(model, "Z"), ncol =ncol(getME(model, "Z")) )
xz_mat<-cbind(z_mat, x_mat)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model@frame)-xz_rank
}
}else if(method=="gee"){
if(length(unique(table(model$id)))!=1) stop("Must have the same number of measurements for each subject")
x_mat=model.matrix(model$formula, model$data)
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(model$data)-x_rank
}else if(df=="containment"){
z_mat=model.matrix(~-1+as.factor(model$id))
xz_mat<-cbind(z_mat, model$model)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model$data)-xz_rank
}
}
return(df_val)
}
model_sum <-corrSeq_summary(corrSeq_results = lmm_fit,
coefficient = "time", contrast=c(0,1,0,0),
p_adj_method = 'BH',
df = 'Satterthwaite',
sort_results = T)
contrast=c(0,1,0,0)
#Save df name in new variable (df is used to save values later)
df_name=df
#Get genenames (names from list)
gene_names <- names(corrSeq_results)
# Is it contrast?
contrast_tf=!is.null(contrast)
## Is it a multiple coefficient test?
joint_flag=ifelse(contrast_tf, nrow(contrast)>1, F)
joint_flag=ifelse(is.na(joint_flag), F, joint_flag)
method="lmm"
if(joint_flag){
df_methods=c("Satterthwaite", "Kenward-Roger")
}else df_methods=c("Satterthwaite", "Kenward-Roger", "containment", "residual")
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
#If using a different method, first just analyze using satterthwait
#This gives us t-statistic, etc.
df2=df
if(!(df %in% c("Satterthwaite", "Kenward-Roger"))) df2="Satterthwaite"
ret2=lmerSeq.contrast(corrSeq_results, contrast_mat = contrast,
p_adj_method = p_adj_method,
ddf=df2, sort_results = sort_results)
?lmerSeq.contrast
contrast=rbind(contrast)
contrast
rbind(contrast)
cont_mat2 <- rbind(c(0, 1, 0, 0),
c(0, 0, 1, 0),
c(0, 0, 0, 1))
rbind(cont_mat2)
cont_mat2
identical(rbind(cont_mat2), cont_mat2)
#' Function to summarize individual regression coefficients
#'
#' Conducts t-tests on individual regression coefficients from models fit from the \code{\link{corrSeq_fit}} function.
#'
#' @param corrSeq_results Results object from running \code{\link{corrSeq_fit}}.
#' @param coefficient Character string or numeric indicator of which coefficient to summarize. Ignored if contrast is specified.
#' @param contrast numeric vector or matrix specifying a contrast of the linear model coefficients to be tested.
#' Number of columns must equal the number of coefficients in the model. If specified, then takes precedence over coefficient.
#' @param p_adj_method Method for adjusting for multiple comparisons (default is Benjamini-Hochberg). See \code{\link[stats]{p.adjust.methods}}.
#' @param df Method for computing degrees of freedom and t-statistics.
#' The options "Satterthwaite" and "Kenward-Roger" can only be used for
#' models fit using nbmm_pl or lmm. Options "containment" and
#' "residual" can be used for models fit using any method. Alternatively, a single numeric value representing the df for all tests can also be given.
#' @param sort_results Should the results table be sorted by adjusted p-value?
#'
#' @return This function returns a list object with the following components:
#'
#' \item{coefficient}{Name of the coefficient being summarized (if given).}
#' \item{contrast_mat}{Contrast matrix (if given)}
#' \item{summary_table}{A summary table including the gene name, estimate, standard error, degrees of freedom, test statistic, and raw and adjusted p-value.}
#' \item{df}{Method for computing the degrees of freedom.}
#' \item{p_adj_method}{Method for adjusting the raw p-values.}
#' \item{singular_fits}{Gene names for genes that resulted in singular model fits. The summary information for these genes will be NA. Not applicable for models fit using \code{"gee"}.}
#' \item{method}{Method used to fit the models.}
#'
#'
#'@author Elizabeth Wynn
#'
#' @seealso \code{\link{corrSeq_fit}} \code{\link{geeglm_small_samp}}, \code{\link{glmm_nb_lmer}}, \code{\link[lmerTest]{lmer}}, \code{\link[glmmADMB]{glmmadmb}}
#' @examples
#' data("simdata")
#' sample_meta_data <- simdata$metadata
#'
#' ## Subset down to 10 observation (i.e. gene)
#' counts=simdata$counts[1:10,]
#
#'
#' ## Fit NBMM-PL models
#' ## Use log(library size) as an offset
#' nbmm_pl_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log_offset),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_pl")
#'
#'
#' ## Summarize the group coefficient with Satterthwaite degrees of freedom
#' model_sum <-corrSeq_summary(corrSeq_results = nbmm_pl_fit,
#'                              coefficient = "group",
#'                              p_adj_method = 'BH',
#'                              df = 'Satterthwaite',
#'                              sort_results = T)
#'
#'
#' @export
#'
corrSeq_summary <- function(corrSeq_results = NULL, # Results object from running lmerSeq.fit
coefficient = NULL, # Character string or numeric indicator of which coefficient to summarize
contrast=NULL, #Matrix with matrix to be tested
p_adj_method = "BH", # Method for adjusting for multiple comparisons (default is Benjamini-Hochberg)
df = "residual", # Method for computing degrees of freedom and t-statistics. Options are "Satterthwaite" and "Kenward-Roger"
sort_results = T # Should the results table be sorted by adjusted p-value?
){
#Save df name in new variable (df is used to save values later)
df_name=df
#Get genenames (names from list)
gene_names <- names(corrSeq_results)
# Is it contrast?
contrast_tf=!is.null(contrast)
## Is it a multiple coefficient test?
joint_flag=ifelse(contrast_tf, nrow(contrast)>1, F)
joint_flag=ifelse(is.na(joint_flag), F, joint_flag)
if(identical(names(corrSeq_results[[1]]),c("fit", "gene"))){
method="lmm"
if(joint_flag){
df_methods=c("Satterthwaite", "Kenward-Roger")
}else df_methods=c("Satterthwaite", "Kenward-Roger", "containment", "residual")
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
#If using a different method, first just analyze using satterthwait
#This gives us t-statistic, etc.
df2=df
if(!(df %in% c("Satterthwaite", "Kenward-Roger"))) df2="Satterthwaite"
if(contrast_tf){
ret2=lmerSeq.contrast(corrSeq_results, contrast_mat = rbind(contrast),
p_adj_method = p_adj_method,
ddf=df2, sort_results = sort_results)
## Remove upper, lower if one dimensional contrast
# Just so results match
if(!joint_flag) ret2$summary_table=ret2$summary_table%>%dplyr::select(-upper, -lower)%>%dplyr::rename(Std.Error="Std..Error")
}else{
ret2=lmerSeq.summary(corrSeq_results, coefficient = coefficient,
p_adj_method = p_adj_method,
ddf=df2, sort_results = sort_results)
ret2$summary_table=ret2$summary_table%>%dplyr::rename(Std.Error="Std..Error")
}
#First non-null model
if(df!=df2){
if(!is.numeric(df)){
idx_non_null_1<-which(sapply(corrSeq_results, function(x) !is.null(x$fit)))[1]
df_new=calc_df(corrSeq_results[[idx_non_null_1]], df = df, method=method)
}
ret2$summary_table<-ret2$summary_table%>%dplyr::mutate(df=ifelse(is.na(df), NA, df_new), p_val_raw=2*pt(-abs(t.value),df=df_new),
p_val_adj=p.adjust(p_val_raw,
method=p_adj_method))
}
#Capitolize column name so it matches with others
colnames(ret2$summary_table)[colnames(ret2$summary_table)=="gene"]<-"Gene"
#get rid of ddf (artifact from lmerseq, gets added later)
ret2$ddf<-NULL
}else{
#Check if models are Null
if( sum(sapply(corrSeq_results, function(x) !(is.null(x))))==0){
stop("Model fits for all genes are null")
}
#Get first non-null model
idx_non_null_1=which(!sapply(corrSeq_results, is.null))[1]
#For gee models
if("geeglm"%in%class(corrSeq_results[[idx_non_null_1]])){
method="gee"
#Get coef names
coef_names <- names(corrSeq_results[[idx_non_null_1]]$coefficients)
#df methods for gee
df_methods=c("containment", "residual")
idx_not_converged<-which(sapply(corrSeq_results, is.null))
idx_converged_not_singular=which(!(1:length(corrSeq_results)%in% idx_not_converged))
}else if(class(corrSeq_results[[idx_non_null_1]])=="glmm_nb_mod"){
method="nbmm_pl"
coef_names<-names(lme4::fixef(corrSeq_results[[idx_non_null_1]]))
if(joint_flag){
df_methods=c("Satterthwaite", "Kenward-Roger")
}else df_methods=c("containment", "residual", "Satterthwaite", "Kenward-Roger")
idx_singular<-which(sapply(corrSeq_results, function(x) if(is.null(x)) F else lme4::isSingular(x)))
idx_not_converged<-which(sapply(corrSeq_results, function(x) if(!is.null(x)) x@converged==F else T))
idx_converged_not_singular <- which(!(1:length(corrSeq_results)%in% c(idx_not_converged, idx_singular)))
}else if(class(corrSeq_results[[idx_non_null_1]])=="glmmadmb"){
method="nbmm_ml"
coef_names=names(coef(corrSeq_results[[idx_non_null_1]]))
idx_not_converged<-which(sapply(corrSeq_results, is.null))
idx_singular<-which(sapply(corrSeq_results, function(x){
any(sapply(x$S, function(x) any(diag(x)<1e-05)))
})
)
idx_converged_not_singular <- which(!(1:length(corrSeq_results)%in% c(idx_not_converged, idx_singular)))
df_methods=c("containment", "residual")
}
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
if(!contrast_tf){
if(is.numeric(coefficient)){
if((coefficient > length(coef_names)) | coefficient < 1){
stop("Coefficient number is invalid")
}
coef_out <- coef_names[coefficient]
}else{
if(!(coefficient %in% coef_names)){
stop("Coefficient name is invalid")
}
coef_out <- coefficient
}
}
if(!(p_adj_method %in% p.adjust.methods)){
stop("Invalid p_adj_method")
}
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
if(df %in% c("Satterthwaite", "Kenward-Roger")){
ret <- do.call(rbind, lapply(corrSeq_results[idx_converged_not_singular], function(x){
# x = corrSeq_results$fitted_models[[1]]
if(!contrast_tf){
res_sub <- summary(x, ddf = df)$coefficients[coefficient, ]
names(res_sub)[names(res_sub)=="Pr(>|t|)"]<-"p_val_raw"
}else{
res_sub<-lmerTest::contest(x, contrast, ddf=df, joint=joint_flag)
names(res_sub)[names(res_sub)%in%c("Pr(>F)","Pr(>|t|)")]<-"p_val_raw"
}
return(res_sub)
}))%>%data.frame()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular],
p_val_adj = p.adjust(p_val_raw, method = p_adj_method))
if(joint_flag){
ret=ret%>%dplyr::select(Gene, Sum.Sq, Mean.Sq,NumDF, DenDF,F.value,
p_val_raw, p_val_adj)
}else{
ret=ret%>%dplyr::select(Gene, Estimate, Std.Error="Std..Error", "df","t.value",
p_val_raw, p_val_adj)
}
}else{
#If df will be same for all models, calculate now
constant_df_methods=c("residual", "containment")
if(df %in% constant_df_methods){
df=calc_df(model = corrSeq_results[[1]],df = df, method=method)
}
ret=lapply(corrSeq_results[idx_converged_not_singular], function(x){
#Estimate and std. error for gee
if(method=="gee"){
Estimate=x$coefficients[coefficient]
#if small sample method was used
if(!is.null(x$small.samp.va)){
Std.Error=sqrt(x$small.samp.var[coefficient])
}else Std.Error=summary(x)$coefficients[coefficient,"Std.err"]
}else if(method=="nbmm_pl"){
if(contrast_tf){
cont=lmerTest::contest(x, L=contrast, joint=F)$Estimate
Estimate=cont$Estimate
Std.Error=cont$`Std. Error`
}else{
Estimate=summary(x)$coefficients[coefficient,"Estimate"]
Std.Error=summary(x)$coefficients[coefficient,"Std. Error"]
}
}else if(method=="nbmm_ml"){
Estimate=summary(x)$coefficient[coefficient, "Estimate"]
Std.Error=summary(x)$coefficient[coefficient, "Std. Error"]
}
if(!is.numeric(df)){
df=calc_df(model=x, df=df, method=method)
}
t.value=Estimate/Std.Error
p_val_raw=2*pt(-abs(t.value),
df=df)
data.frame(Estimate=Estimate, Std.Error=Std.Error, df=df,
t.value=t.value, p_val_raw=p_val_raw)
})%>%dplyr::bind_rows()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular], p_val_adj=p.adjust(p_val_raw, method = p_adj_method))%>%
dplyr::select(Gene, Estimate, Std.Error, df, t.value, p_val_raw, p_val_adj)
}
rownames(ret) <- NULL
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
if(method !="gee"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
}
ret2$summary_table<-ret2$summary_table[match(gene_names,
ret2$summary_table$Gene),]
if(sort_results){
ret2$summary_table <- ret2$summary_table %>%
dplyr::arrange(p_val_adj)
}
ret2$model_method=method
ret2$df=df_name
rownames(ret2$summary_table)<-NULL
return(ret2)
}
########################################
#Calculate containment and residual df
########################################
calc_df<-function(model, df, method){
if(method=="lmm"|method=="nbmm_pl"|method=="nbmm_ml"){
#if nbmm_ml, fit lmm in order to get zmat and xmat
if(method=="nbmm_ml") model=lme4::lmer(formula = model$formula, data=model$data)
if(method=="lmm") model=model$fit
ids<-names(ranef(model))
#Mistake-not arequirement to have same number of measurements for each subject
#if(length(unique(table(model@frame[,ids])))!=1) stop("Must have the same number of measurements for each subject")
x_mat=matrix(getME(model, "X"), ncol =ncol(getME(model, "X")))
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(x_mat)-x_rank
}else if(df=="containment"){
z_mat<-matrix(getME(model, "Z"), ncol =ncol(getME(model, "Z")) )
xz_mat<-cbind(z_mat, x_mat)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model@frame)-xz_rank
}
}else if(method=="gee"){
if(length(unique(table(model$id)))!=1) stop("Must have the same number of measurements for each subject")
x_mat=model.matrix(model$formula, model$data)
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(model$data)-x_rank
}else if(df=="containment"){
z_mat=model.matrix(~-1+as.factor(model$id))
xz_mat<-cbind(z_mat, model$model)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model$data)-xz_rank
}
}
return(df_val)
}
model_sum <-corrSeq_summary(corrSeq_results = lmm_fit,
coefficient = "time", contrast=c(0,1,0,0),
p_adj_method = 'BH',
df = 'Satterthwaite',
sort_results = T)
model_sum2 <-corrSeq_summary(corrSeq_results = lmm_fit,
coefficient = "time", contrast=c(0,1,0,0),
p_adj_method = 'BH',
df = 'Satterthwaite',
sort_results = T)
View(model_sum)
model_sum <-corrSeq_summary(corrSeq_results = lmm_fit,
coefficient = "group",
p_adj_method = 'BH',
df = 'Satterthwaite',
sort_results = T)
View(model_sum)
View(model_sum2)
View(model_sum2[["summary_table"]])
View(model_sum[["summary_table"]])
model_sum2 <-corrSeq_summary(corrSeq_results = lmm_fit,
contrast=rbind(c(0,1,0,0), c(0,0,1,0)),
p_adj_method = 'BH',
df = 'Satterthwaite',
sort_results = T)
View(model_sum2)
View(model_sum2[["summary_table"]])
library(corrRNASeq)
?corrSeq_summary
library(corrRNASeq)
?corrSeq_fit
?corrSeq_summary
library(corrRNASeq)
?corrSeq_summary
