vc_val<-vc[,4]
# Create variance covariance matrix for all random effects (block diagonal matrix)
G.mat <- matrix(NA,length(vc$var2[vc$var2=="<NA>"]),length(vc$var2[vc$var2=="<NA>"]))
G.mat[lower.tri(G.mat,diag=TRUE)] <- vc$vcov
G.mat <- makeSymm(G.mat)
mat_list <- rep(G.mat, lme4::ngrps(fit))
my_G <- Matrix::bdiag(  ## make a block-diagonal matrix
lapply(
split(mat_list, rep(1:lme4::ngrps(fit), each=length(G.mat))),
matrix,dim(G.mat)))
# Calculate dispersion
error<-0
tryCatch(
th <- calc_dispersion(my_m, eta_fixed, my_G, mf$zz, mu, Z),
error=function(err){error<<-1})
if(error==0) {
th<-th
# Add 1 to number of iterations on new equation
j <- j+1
}
if(error==1){ th<- suppressWarnings(
MASS::theta.ml(y=y, mu=mu, n=sum(wts), weights=wts, limit=niter_theta.ml,
trace=FALSE))
# If need to use theta.ml, then j=0.
j=0}
fam <- NegBin(theta = th)
#Output all thetas
my_theta[i]<-th
#stop loop if old and new fitted values not that different and old and new theta's not that different
#And has run in the new equation 5 or more times
#if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2 & ((vc_old_val-vc_val)^2)<epsilon*vc_val^2 & j>=niter_theta) break
if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2) break
# Update pseudo-response variable
mf$zz <- eta + (y - mu)/mu.eta.val
# Calculate variance
varmu <- fam$variance(mu)
# If varmu is 0 set to small number
varmu <- ifelse(varmu == 0, 1e-04, varmu)
# Update weights for LMM on pseudo responses
wz <- w * mu.eta.val^2/varmu
wz <- ifelse(wz == 0, 1e-04, wz)
mcall$weights<-wz
# update data (since zz changed)
mcall$data <- mf
}
if (!(sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2)) warning("Model did not converge")
# None of these lines would work with lmer (because no list names?)
# CMM - lmer objects are funny.  You have to use attributes(fit).  See my examples below.
#get rid of loglik info (no list item names in lmerTest so won't work)
###attributes(fit$logLik) <- NULL
#fit$call outputs model formula
attributes(fit)$call <- Call #CMM
#save number of iterations
attributes(fit)$iter <- i #CMM
#logLik as NA
###fit$logLik <- as.numeric(NA) #I'd like to keep the LL or we could include it in a new slot called pseudo-likelihood
#save theta value
attributes(fit)$dispersion <- fam$theta #CMM
#nbmm as old class fit?
###oldClass(fit) <- c("nbmm", oldClass(fit))
stop.time <- Sys.time()
minutes <- round(difftime(stop.time, start.time, units = "min"), 3)
if (verbose) {
cat("Computational iterations:", attributes(fit)$iter, "\n") #CMM
cat("Computational time:", minutes, "minutes \n")
}
#returns fitted model
fit<-as(fit, "glmm_nb_mod")
fit
}
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(lib_size)+ (1|ids),
data=df, REML = T)
View(mf)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(lib_size)+ (1|ids),
data=df, REML = T)
fixed
mf
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
View(fit0)
log(df$lib_size)
View(mf)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
glmm_nb_lmer<-function (formula, data, niter = 40, epsilon = 1e-08, verbose = TRUE, REML=TRUE){
browser()
niter_theta=5
niter_theta.ml = 5
start.time <- Sys.time()
#Function inside of packag
family <- NegBin()
m <- mcall <- Call <- match.call()
#Seems unnecessary
# CMM: I'm also not so sure what this is doing...probably something with keeping names for the model output
# we might figure it out when we use the function more
nm <- names(m)[-1L]
keep <- is.element(nm, c("weights", "data", "subset", "na.action")) #?
for (i in nm[!keep]) m[[i]] <- NULL
# Save all variable names, random and fixed
allvars<-all.vars(formula)
# Save formula of just fixed effects
fixed<-lme4::nobars(formula)
Terms <- if (missing(data)) terms(fixed) else terms(fixed, data = data)
# Which term is the offset?
off <- attr(Terms, "offset")
off_name<-all.vars(fixed)[off]
# If there is an offset, then it's saving on offset variable name
if (length(off <- attr(Terms, "offset")))
allvars <- c(allvars, as.character(attr(Terms, "variables"))[off + 1])
#Save formula for output later
Call$formula<-formula
m$formula <- as.formula(paste(allvars[1],"~", paste(allvars[-c(1)], collapse = "+")))
#Make sure m$formula environment the fixed environment (don't know why that's necessary)
environment(m$formula) <- environment(fixed)
#Set up call for model.frame function
m$drop.unused.levels <- TRUE
m[[1L]] <- quote(stats::model.frame)
#Run model.frame -Returns df with counts, time, group, log_offset, id for each participant
mf <- eval.parent(m)
# Offset for the model
off <- model.offset(mf)
#sets offset to 0 if null
if (is.null(off)) off <- 0
# extracts weights if there are any
wts <- model.weights(mf)
# If weights is null, make all weights equal to 1 and save to mf
if (is.null(wts)) wts <- rep(1, nrow(mf))
mf$wts <- wts
#Fit initial model
fit0<-MASS::glm.nb(formula = fixed, data=mf)
# Saving prior weights and linear predictors from model
w <- fit0$prior.weights
eta <- fit0$linear.predictors
# Starting values for pseudo data
zz <- eta + fit0$residuals
# Starting values for weights
wz <- fit0$weights
#Don't know what this is for (again)
nm <- names(mcall)[-1L]
keep <- is.element(nm, c("fixed", "random", "data", "subset", "na.action", "control"))
for (i in nm[!keep]) mcall[[i]] <- NULL
# Replace the outcome is replaced with the transformation for LMM models on pseudo data
formula[[2L]] <- quote(zz)
mcall[["formula"]]<-formula #
# Saves lmer function call (use lmerTest so we can get p-values)
mcall[[1L]] <- quote(lmerTest::lmer)
# Set REML to True or false based on function argument
mcall$REML <- REML
# Input updated weights
mcall$weights<-wz
# Add pseudo data to model data frame
mf$zz<-zz
#saves mf df (variables, weights, zz) as data
mcall$data <- mf
# Get outcome data
y <- fit0$y
# Vector to hold theta for each iteration
my_theta <- vector()
# Initialize number of iterations on calc_disp function
j <- 0
# Use theta from glm.nb in as first theta estimate
fam <- NegBin(theta = fit0$theta)
th <- th_old <- fam$theta
vc<-NULL
# for loop goes set number of iterations (specified in the call)
for (i in seq_len(niter)) {
#Evaluate function created from above info
fit <- eval(mcall)
Z <- t(as.matrix(attributes(fit)$pp$Zt))
X <- model.matrix(fit)
# preveious model linear predictors
etaold <- eta
# new model linear predictors
eta <- fitted(fit)
# new model linear predictors (fixed effects only)
eta_fixed <- X%*%attributes(fit)$beta + off
#Next to lines deal with negbin function, don't understand
# CMM: These lines calculate the expected value for each observation based on the model and the variance
# uses formulas from the negative binomial distribution
mu <- fam$linkinv(eta) #same as exp(eta)
mu.eta.val <- fam$mu.eta(eta) #Always equal to mu: mu.eta is just doing pmax(exp(eta), .Machine$double.eps)
#set mu.eta.val to small number if equal to 0
mu.eta.val <- ifelse(mu.eta.val == 0, 1e-04, mu.eta.val)
# Update the dispersion parameter
th_old <- th
# Calculate parameters to find dispersion
my_m <- nrow(model.matrix(fit))-ncol(model.matrix(fit))
# Get variance components for random effects
vc_old<-vc
if (j==0) vc_old_val<-0
else vc_old_val<-vc_old[,4]
vc <- lme4::VarCorr(fit)
vc <- as.data.frame(vc,order="lower.tri")
vc <- vc[vc$grp != "Residual",]
vc_val<-vc[,4]
# Create variance covariance matrix for all random effects (block diagonal matrix)
G.mat <- matrix(NA,length(vc$var2[vc$var2=="<NA>"]),length(vc$var2[vc$var2=="<NA>"]))
G.mat[lower.tri(G.mat,diag=TRUE)] <- vc$vcov
G.mat <- makeSymm(G.mat)
mat_list <- rep(G.mat, lme4::ngrps(fit))
my_G <- Matrix::bdiag(  ## make a block-diagonal matrix
lapply(
split(mat_list, rep(1:lme4::ngrps(fit), each=length(G.mat))),
matrix,dim(G.mat)))
# Calculate dispersion
error<-0
tryCatch(
th <- calc_dispersion(my_m, eta_fixed, my_G, mf$zz, mu, Z),
error=function(err){error<<-1})
if(error==0) {
th<-th
# Add 1 to number of iterations on new equation
j <- j+1
}
if(error==1){ th<- suppressWarnings(
MASS::theta.ml(y=y, mu=mu, n=sum(wts), weights=wts, limit=niter_theta.ml,
trace=FALSE))
# If need to use theta.ml, then j=0.
j=0}
fam <- NegBin(theta = th)
#Output all thetas
my_theta[i]<-th
#stop loop if old and new fitted values not that different and old and new theta's not that different
#And has run in the new equation 5 or more times
#if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2 & ((vc_old_val-vc_val)^2)<epsilon*vc_val^2 & j>=niter_theta) break
if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2) break
# Update pseudo-response variable
mf$zz <- eta + (y - mu)/mu.eta.val
# Calculate variance
varmu <- fam$variance(mu)
# If varmu is 0 set to small number
varmu <- ifelse(varmu == 0, 1e-04, varmu)
# Update weights for LMM on pseudo responses
wz <- w * mu.eta.val^2/varmu
wz <- ifelse(wz == 0, 1e-04, wz)
mcall$weights<-wz
# update data (since zz changed)
mcall$data <- mf
}
if (!(sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2)) warning("Model did not converge")
# None of these lines would work with lmer (because no list names?)
# CMM - lmer objects are funny.  You have to use attributes(fit).  See my examples below.
#get rid of loglik info (no list item names in lmerTest so won't work)
###attributes(fit$logLik) <- NULL
#fit$call outputs model formula
attributes(fit)$call <- Call #CMM
#save number of iterations
attributes(fit)$iter <- i #CMM
#logLik as NA
###fit$logLik <- as.numeric(NA) #I'd like to keep the LL or we could include it in a new slot called pseudo-likelihood
#save theta value
attributes(fit)$dispersion <- fam$theta #CMM
#nbmm as old class fit?
###oldClass(fit) <- c("nbmm", oldClass(fit))
stop.time <- Sys.time()
minutes <- round(difftime(stop.time, start.time, units = "min"), 3)
if (verbose) {
cat("Computational iterations:", attributes(fit)$iter, "\n") #CMM
cat("Computational time:", minutes, "minutes \n")
}
#returns fitted model
fit<-as(fit, "glmm_nb_mod")
fit
}
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
m
View(mf)
View(fit0)
View(mf)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
m
df$lib_size
log(df$lib_size)
glmm_nb_lmer<-function (formula, data, niter = 40, epsilon = 1e-08, verbose = TRUE, REML=TRUE){
niter_theta=5
niter_theta.ml = 5
start.time <- Sys.time()
#Function inside of packag
family <- NegBin()
m <- mcall <- Call <- match.call()
#Seems unnecessary
# CMM: I'm also not so sure what this is doing...probably something with keeping names for the model output
# we might figure it out when we use the function more
nm <- names(m)[-1L]
keep <- is.element(nm, c("weights", "data", "subset", "na.action")) #?
for (i in nm[!keep]) m[[i]] <- NULL
# Save all variable names, random and fixed
allvars<-all.vars(formula)
# Save formula of just fixed effects
fixed<-lme4::nobars(formula)
Terms <- if (missing(data)) terms(fixed) else terms(fixed, data = data)
# Which term is the offset?
off <- attr(Terms, "offset")
off_name<-all.vars(fixed)[off]
# If there is an offset, then it's saving on offset variable name
if (length(off <- attr(Terms, "offset")))
allvars <- c(allvars, as.character(attr(Terms, "variables"))[off + 1])
#Save formula for output later
Call$formula<-formula
m$formula <- as.formula(paste(allvars[1],"~", paste(allvars[-c(1)], collapse = "+")))
#Make sure m$formula environment the fixed environment (don't know why that's necessary)
environment(m$formula) <- environment(fixed)
#Set up call for model.frame function
m$drop.unused.levels <- TRUE
m[[1L]] <- quote(stats::model.frame)
#Run model.frame -Returns df with counts, time, group, log_offset, id for each participant
mf <- eval.parent(m)
# Offset for the model
off <- model.offset(mf)
#sets offset to 0 if null
if (is.null(off)) off <- 0
# extracts weights if there are any
wts <- model.weights(mf)
# If weights is null, make all weights equal to 1 and save to mf
if (is.null(wts)) wts <- rep(1, nrow(mf))
mf$wts <- wts
#Fit initial model
fit0<-MASS::glm.nb(formula = fixed, data=mf)
# Saving prior weights and linear predictors from model
w <- fit0$prior.weights
eta <- fit0$linear.predictors
# Starting values for pseudo data
zz <- eta + fit0$residuals
# Starting values for weights
wz <- fit0$weights
#Don't know what this is for (again)
nm <- names(mcall)[-1L]
keep <- is.element(nm, c("fixed", "random", "data", "subset", "na.action", "control"))
for (i in nm[!keep]) mcall[[i]] <- NULL
# Replace the outcome is replaced with the transformation for LMM models on pseudo data
formula[[2L]] <- quote(zz)
mcall[["formula"]]<-formula #
# Saves lmer function call (use lmerTest so we can get p-values)
mcall[[1L]] <- quote(lmerTest::lmer)
# Set REML to True or false based on function argument
mcall$REML <- REML
# Input updated weights
mcall$weights<-wz
# Add pseudo data to model data frame
mf$zz<-zz
#saves mf df (variables, weights, zz) as data
mcall$data <- mf
# Get outcome data
y <- fit0$y
# Vector to hold theta for each iteration
my_theta <- vector()
# Initialize number of iterations on calc_disp function
j <- 0
# Use theta from glm.nb in as first theta estimate
fam <- NegBin(theta = fit0$theta)
th <- th_old <- fam$theta
vc<-NULL
# for loop goes set number of iterations (specified in the call)
for (i in seq_len(niter)) {
#Evaluate function created from above info
fit <- eval(mcall)
Z <- t(as.matrix(attributes(fit)$pp$Zt))
X <- model.matrix(fit)
# preveious model linear predictors
etaold <- eta
# new model linear predictors
eta <- fitted(fit)
# new model linear predictors (fixed effects only)
eta_fixed <- X%*%attributes(fit)$beta + off
#Next to lines deal with negbin function, don't understand
# CMM: These lines calculate the expected value for each observation based on the model and the variance
# uses formulas from the negative binomial distribution
mu <- fam$linkinv(eta) #same as exp(eta)
mu.eta.val <- fam$mu.eta(eta) #Always equal to mu: mu.eta is just doing pmax(exp(eta), .Machine$double.eps)
#set mu.eta.val to small number if equal to 0
mu.eta.val <- ifelse(mu.eta.val == 0, 1e-04, mu.eta.val)
# Update the dispersion parameter
th_old <- th
# Calculate parameters to find dispersion
my_m <- nrow(model.matrix(fit))-ncol(model.matrix(fit))
# Get variance components for random effects
vc_old<-vc
if (j==0) vc_old_val<-0
else vc_old_val<-vc_old[,4]
vc <- lme4::VarCorr(fit)
vc <- as.data.frame(vc,order="lower.tri")
vc <- vc[vc$grp != "Residual",]
vc_val<-vc[,4]
# Create variance covariance matrix for all random effects (block diagonal matrix)
G.mat <- matrix(NA,length(vc$var2[vc$var2=="<NA>"]),length(vc$var2[vc$var2=="<NA>"]))
G.mat[lower.tri(G.mat,diag=TRUE)] <- vc$vcov
G.mat <- makeSymm(G.mat)
mat_list <- rep(G.mat, lme4::ngrps(fit))
my_G <- Matrix::bdiag(  ## make a block-diagonal matrix
lapply(
split(mat_list, rep(1:lme4::ngrps(fit), each=length(G.mat))),
matrix,dim(G.mat)))
# Calculate dispersion
error<-0
tryCatch(
th <- calc_dispersion(my_m, eta_fixed, my_G, mf$zz, mu, Z),
error=function(err){error<<-1})
if(error==0) {
th<-th
# Add 1 to number of iterations on new equation
j <- j+1
}
if(error==1){ th<- suppressWarnings(
MASS::theta.ml(y=y, mu=mu, n=sum(wts), weights=wts, limit=niter_theta.ml,
trace=FALSE))
# If need to use theta.ml, then j=0.
j=0}
fam <- NegBin(theta = th)
#Output all thetas
my_theta[i]<-th
#stop loop if old and new fitted values not that different and old and new theta's not that different
#And has run in the new equation 5 or more times
#if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2 & ((vc_old_val-vc_val)^2)<epsilon*vc_val^2 & j>=niter_theta) break
if (sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2) break
# Update pseudo-response variable
mf$zz <- eta + (y - mu)/mu.eta.val
# Calculate variance
varmu <- fam$variance(mu)
# If varmu is 0 set to small number
varmu <- ifelse(varmu == 0, 1e-04, varmu)
# Update weights for LMM on pseudo responses
wz <- w * mu.eta.val^2/varmu
wz <- ifelse(wz == 0, 1e-04, wz)
mcall$weights<-wz
# update data (since zz changed)
mcall$data <- mf
}
if (!(sum((eta - etaold)^2) < epsilon * sum(eta^2) & abs((th_old-th)^2)<epsilon*th^2)) warning("Model did not converge")
# None of these lines would work with lmer (because no list names?)
# CMM - lmer objects are funny.  You have to use attributes(fit).  See my examples below.
#get rid of loglik info (no list item names in lmerTest so won't work)
###attributes(fit$logLik) <- NULL
#fit$call outputs model formula
attributes(fit)$call <- Call #CMM
#save number of iterations
attributes(fit)$iter <- i #CMM
#logLik as NA
###fit$logLik <- as.numeric(NA) #I'd like to keep the LL or we could include it in a new slot called pseudo-likelihood
#save theta value
attributes(fit)$dispersion <- fam$theta #CMM
#nbmm as old class fit?
###oldClass(fit) <- c("nbmm", oldClass(fit))
stop.time <- Sys.time()
minutes <- round(difftime(stop.time, start.time, units = "min"), 3)
if (verbose) {
cat("Computational iterations:", attributes(fit)$iter, "\n") #CMM
cat("Computational time:", minutes, "minutes \n")
}
#returns fitted model
fit<-as(fit, "glmm_nb_mod")
fit
}
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
library(corrRNASeq)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +offset(log(lib_size))+ (1|ids),
data=df, REML = T)
data("simdata")
sample_meta_data <- simdata$metadata
#Subset down to one observation (i.e. gene)
counts=simdata$counts[1,]
#Combine counts, metadata into dataframe
df=cbind(counts, sample_meta_data)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time + offset(log(lib_size)+(1|ids),
data=df, REML = T)
)))))))))))
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time + offset(log(lib_size))+(1|ids),
data=df, REML = T)
View(fit.glmm.nb)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +(1|ids)+offset(log(lib_size)),
data=df, REML = T)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time +(1|ids)+offset(log(lib_size)),
data=df, REML = T)
fit.glmm.nb2 <- glmm_nb_lmer(formula =counts ~ group * time +(1|ids)+offset(log(lib_size)),
data=df, REML = T)
fit.glmm.nb <- glmm_nb_lmer(formula =counts ~ group * time + offset(log(lib_size))+(1|ids),
data=df, REML = T)
summary(fit.glmm.nb)
summary(fit.glmm.nb2)
?corrSeq_fit
data("simdata")
sample_meta_data <- simdata$metadata
## Subset down to 10 observation (i.e. gene)
counts=simdata$counts[1:10,]
## Compute library sizes (to be used as offsets)
sample_meta_data$lib_size<-colSums(counts)
## Fit GEE models using Wang-Long small sample size estimator
gee_fit <- corrSeq_fit(formula = ~ group * time+offset(log(lib_size)),
expr_mat = counts,
sample_data = sample_meta_data,
method="gee",
id=ids,
small.samp.method="wl")
## Fit NBMM-PL models
nbmm_pl_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
expr_mat = counts,
sample_data = sample_meta_data,
method="nbmm_pl")
View(nbmm_pl_fit)
View(gee_fit)
## Fit NBMM-ML models
## Random effects must be factors
sample_meta_data$ids<-factor(sample_meta_data$ids)
nbmm_ml_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log(lib_size)),
expr_mat = counts,
sample_data = sample_meta_data,
method="nbmm_ml")
log(simdata$metadata$lib_size)
devtools::document()
devtools::document()
