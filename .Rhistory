if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
ret2$summary_table
idx_singular=1
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
ret2$summary_table
genes_null
genes_null=c("gene_1", "gene_2")
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
if(method !="gee"&method!="ptmixed"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
ret2$summary_table
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
if(method !="gee"&method!="ptmixed"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
View(ret2)
View(ret2[["summary_table"]])
?gtools::smartbind
genes_null="gene_11"
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
genes_null
View(ret2)
View(ret2[["summary_table"]])
genes_null=c("Gene_11", "gene_12")
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
View(ret2)
View(ret2[["summary_table"]])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
class(ret2$summary_table$Gene)
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
df1 <- data.frame(A = 1:10, B = LETTERS[1:10], C = rnorm(10))
df2 <- data.frame(A = 11:20, D = rnorm(10), E = letters[1:10])
smartbind(df1, df2)
library(gtools)
library(gtools)
smartbind(df1, df2)
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = ret,
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = ret,
p_adj_method = p_adj_method)
}
class(ret2$summary_table)
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = data.frame(ret),
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = data.frame(ret),
p_adj_method = p_adj_method)
}
class(ret2$summary_table)
if(method !="gee"&method!="ptmixed"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
View(ret2)
View(ret2[["summary_table"]])
#' Function to summarize individual regression coefficients
#'
#' Conducts t-tests on individual regression coefficients from models fit from the \code{\link{corrSeq_fit}} function.
#'
#' @param corrSeq_results Results object from running \code{\link{corrSeq_fit}}.
#' @param coefficient Character string or numeric indicator of which coefficient to summarize. Ignored if contrast is specified.
#' @param contrast numeric vector or matrix specifying a contrast of the linear model coefficients to be tested.
#' Number of columns must equal the number of coefficients in the model. If specified, then takes precedence over coefficient.
#' @param p_adj_method Method for adjusting for multiple comparisons (default is Benjamini-Hochberg). See \code{\link[stats]{p.adjust.methods}}.
#' @param df Method for computing degrees of freedom and t-statistics.
#' The options "Satterthwaite" and "Kenward-Roger" can only be used for
#' models fit using nbmm_pl or lmm. Options "containment" and
#' "residual" can be used for models fit using any method. Alternatively, a single numeric value representing the df for all tests can also be given.
#' @param sort_results Should the results table be sorted by adjusted p-value?
#'
#' @return This function returns a list object with the following components:
#'
#' \item{coefficient}{Name of the coefficient being summarized (if given).}
#' \item{contrast_mat}{Contrast matrix (if given)}
#' \item{summary_table}{A summary table including the gene name, estimate, standard error, degrees of freedom, test statistic, and raw and adjusted p-value.}
#' \item{df}{Method for computing the degrees of freedom.}
#' \item{p_adj_method}{Method for adjusting the raw p-values.}
#' \item{singular_fits}{Gene names for genes that resulted in singular model fits. The summary information for these genes will be NA. Not applicable for models fit using \code{"gee"}.}
#' \item{method}{Method used to fit the models.}
#'
#'
#'@author Elizabeth Wynn
#'
#' @seealso \code{\link{corrSeq_fit}} \code{\link{geeglm_small_samp}}, \code{\link{glmm_nb_lmer}}, \code{\link[lmerTest]{lmer}}, \code{\link[glmmADMB]{glmmadmb}}
#' @examples
#' data("simdata")
#' sample_meta_data <- simdata$metadata
#'
#' ## Subset down to 10 observation (i.e. gene)
#' counts=simdata$counts[1:10,]
#
#'
#' ## Fit NBMM-PL models
#' ## Use log(library size) as an offset
#' nbmm_pl_fit <- corrSeq_fit(formula = ~ group * time+(1|ids)+offset(log_offset),
#'                            expr_mat = counts,
#'                            sample_data = sample_meta_data,
#'                            method="nbmm_pl")
#'
#'
#' ## Summarize the group coefficient with Satterthwaite degrees of freedom
#' model_sum <-corrSeq_summary(corrSeq_results = nbmm_pl_fit,
#'                              coefficient = "group",
#'                              p_adj_method = 'BH',
#'                              df = 'Satterthwaite',
#'                              sort_results = T)
#'
#'
#' @export
#'
corrSeq_summary <- function(corrSeq_results = NULL, # Results object from running lmerSeq.fit
coefficient = NULL, # Character string or numeric indicator of which coefficient to summarize
contrast=NULL, #Matrix with matrix to be tested
p_adj_method = "BH", # Method for adjusting for multiple comparisons (default is Benjamini-Hochberg)
df = "residual", # Method for computing degrees of freedom and t-statistics. Options are "Satterthwaite" and "Kenward-Roger"
sort_results = T # Should the results table be sorted by adjusted p-value?
){
#Save df name in new variable (df is used to save values later)
df_name=df
#Get genenames (names from list)
gene_names <- names(corrSeq_results)
# Is it contrast?
contrast_tf=!is.null(contrast)
## Is it a multiple coefficient test?
joint_flag=ifelse(contrast_tf, nrow(contrast)>1, F)
joint_flag=ifelse(is.na(joint_flag), F, joint_flag)
if(identical(names(corrSeq_results[[1]]),c("fit", "gene"))){
method="lmm"
if(joint_flag){
df_methods=c("Satterthwaite", "Kenward-Roger")
}else df_methods=c("Satterthwaite", "Kenward-Roger", "containment", "residual")
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
#If using a different method, first just analyze using satterthwait
#This gives us t-statistic, etc.
df2=df
if(!(df %in% c("Satterthwaite", "Kenward-Roger"))) df2="Satterthwaite"
if(contrast_tf){
ret2=lmerSeq.contrast(corrSeq_results, contrast_mat = rbind(contrast),
p_adj_method = p_adj_method,
ddf=df2, sort_results = sort_results)
## Remove upper, lower if one dimensional contrast
# Just so results match
if(!joint_flag) ret2$summary_table=ret2$summary_table%>%dplyr::select(-upper, -lower)%>%dplyr::rename(Std.Error="Std..Error")
}else{
ret2=lmerSeq.summary(corrSeq_results, coefficient = coefficient,
p_adj_method = p_adj_method,
ddf=df2, sort_results = sort_results)
ret2$summary_table=ret2$summary_table%>%dplyr::rename(Std.Error="Std..Error")
}
#First non-null model
if(df!=df2){
if(!is.numeric(df)){
idx_non_null_1<-which(sapply(corrSeq_results, function(x) !is.null(x$fit)))[1]
df_new=calc_df(corrSeq_results[[idx_non_null_1]], df = df, method=method)
}
ret2$summary_table<-ret2$summary_table%>%dplyr::mutate(df=ifelse(is.na(df), NA, df_new), p_val_raw=2*pt(-abs(t.value),df=df_new),
p_val_adj=p.adjust(p_val_raw,
method=p_adj_method))
}
#Capitolize column name so it matches with others
colnames(ret2$summary_table)[colnames(ret2$summary_table)=="gene"]<-"Gene"
#get rid of ddf (artifact from lmerseq, gets added later)
ret2$ddf<-NULL
}else{
#Check if models are Null
if( sum(sapply(corrSeq_results, function(x) !(is.null(x))))==0){
stop("Model fits for all genes are null")
}
#Get first non-null model
idx_non_null_1=which(!sapply(corrSeq_results, is.null))[1]
#For gee models
if("geeglm"%in%class(corrSeq_results[[idx_non_null_1]])){
method="gee"
#Get coef names
coef_names <- names(corrSeq_results[[idx_non_null_1]]$coefficients)
#df methods for gee
df_methods=c("containment", "residual")
idx_not_converged<-which(sapply(corrSeq_results, is.null))
idx_converged_not_singular=which(!(1:length(corrSeq_results)%in% idx_not_converged))
}else if(class(corrSeq_results[[idx_non_null_1]])=="glmm_nb_mod"){
method="nbmm_pl"
coef_names<-names(lme4::fixef(corrSeq_results[[idx_non_null_1]]))
if(joint_flag){
df_methods=c("Satterthwaite", "Kenward-Roger")
}else df_methods=c("containment", "residual", "Satterthwaite", "Kenward-Roger")
idx_singular<-which(sapply(corrSeq_results, function(x) if(is.null(x)) F else lme4::isSingular(x)))
idx_not_converged<-which(sapply(corrSeq_results, function(x) if(!is.null(x)) x@converged==F else T))
idx_converged_not_singular <- which(!(1:length(corrSeq_results)%in% c(idx_not_converged, idx_singular)))
}else if(class(corrSeq_results[[idx_non_null_1]])=="glmmadmb"){
method="nbmm_ml"
coef_names=names(coef(corrSeq_results[[idx_non_null_1]]))
idx_not_converged<-which(sapply(corrSeq_results, is.null))
idx_singular<-which(sapply(corrSeq_results, function(x){
any(sapply(x$S, function(x) any(diag(x)<1e-05)))
})
)
idx_converged_not_singular <- which(!(1:length(corrSeq_results)%in% c(idx_not_converged, idx_singular)))
df_methods=c("containment", "residual")
}else if("ptglmm" %in% class(corrSeq_results[[idx_non_null_1]])){
method="ptmixed"
coef_names=rownames(summary(corrSeq_results[[idx_non_null_1]], wald=F, silent=T)$coefficients)
idx_not_converged<-which(sapply(corrSeq_results, function(x) ifelse(is.null(x$convergence), T, x$convergence!=0)))
idx_converged_not_singular=which(!(1:length(corrSeq_results)%in% idx_not_converged))
df_methods=NA
}else if(class(corrSeq_results[[idx_non_null_1]])=="MixMod"){
method="nbmm_adq"
coef_names=names(corrSeq_results[[idx_non_null_1]]$coefficients)
idx_not_converged<-which(sapply(corrSeq_results, function(x) ifelse(is.null(x$converged), T, !x$converged)))
idx_singular<-which(sapply(corrSeq_results, function(x){
any(diag(x$D)<1e-05)
}))
idx_converged_not_singular <- which(!(1:length(corrSeq_results)%in% c(idx_not_converged, idx_singular)))
df_methods=NA
}
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
if(!contrast_tf){
if(is.numeric(coefficient)){
if((coefficient > length(coef_names)) | coefficient < 1){
stop("Coefficient number is invalid")
}
coef_out <- coef_names[coefficient]
}else{
if(!(coefficient %in% coef_names)){
stop("Coefficient name is invalid")
}
coef_out <- coefficient
}
}
if(!(p_adj_method %in% p.adjust.methods)){
stop("Invalid p_adj_method")
}
if(!(df %in% df_methods)&!is.numeric(df)){
stop("Invalid df method")
}
if(df %in% c("Satterthwaite", "Kenward-Roger")){
ret <- do.call(rbind, lapply(corrSeq_results[idx_converged_not_singular], function(x){
# x = corrSeq_results$fitted_models[[1]]
if(!contrast_tf){
res_sub <- summary(x, ddf = df)$coefficients[coefficient, ]
names(res_sub)[names(res_sub)=="Pr(>|t|)"]<-"p_val_raw"
}else{
res_sub<-lmerTest::contest(x, contrast, ddf=df, joint=joint_flag)
names(res_sub)[names(res_sub)%in%c("Pr(>F)","Pr(>|t|)")]<-"p_val_raw"
}
return(res_sub)
}))%>%data.frame()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular],
p_val_adj = p.adjust(p_val_raw, method = p_adj_method))
if(joint_flag){
ret=ret%>%dplyr::select(Gene, Sum.Sq, Mean.Sq,NumDF, DenDF,F.value,
p_val_raw, p_val_adj)
}else{
ret=ret%>%dplyr::select(Gene, Estimate, Std.Error="Std..Error", "df","t.value",
p_val_raw, p_val_adj)
}
}else{
#If df will be same for all models, calculate now
constant_df_methods=c("residual", "containment")
if(df %in% constant_df_methods){
df=calc_df(model = corrSeq_results[[1]],df = df, method=method)
}
ret=lapply(corrSeq_results[idx_converged_not_singular], function(x){
#Estimate and std. error for gee
if(method=="gee"){
Estimate=x$coefficients[coefficient]
#if small sample method was used
if(!is.null(x$small.samp.va)){
Std.Error=sqrt(x$small.samp.var[coefficient])
}else Std.Error=summary(x)$coefficients[coefficient,"Std.err"]
}else if(method=="nbmm_pl"){
if(contrast_tf){
cont=lmerTest::contest(x, L=contrast, joint=F)$Estimate
Estimate=cont$Estimate
Std.Error=cont$`Std. Error`
}else{
Estimate=summary(x)$coefficients[coefficient,"Estimate"]
Std.Error=summary(x)$coefficients[coefficient,"Std. Error"]
}
}else if(method=="nbmm_ml"){
Estimate=summary(x)$coefficient[coefficient, "Estimate"]
Std.Error=summary(x)$coefficient[coefficient, "Std. Error"]
}
if(!is.numeric(df)&method!="ptmixed"&method!="nbmm_adq"){
df=calc_df(model=x, df=df, method=method)
}
if(method!="ptmixed"& method!="nbmm_adq"){
t.value=Estimate/Std.Error
p_val_raw=2*pt(-abs(t.value),
df=df)
df=data.frame(Estimate=Estimate, Std.Error=Std.Error, df=df,
t.value=t.value, p_val_raw=p_val_raw)
}else if(method=="ptmixed"){
if(contrast_tf){
df=tryCatch({ptmixed::wald.test(x, L=contrast)},
error = function(e) {
data.frame(chi2=NA, df=NA, P=NA)
})
names(df)[names(df)=="P"]<-"p_val_raw"
names(df)[names(df)=="chi2"]<-"Chisq"
}else{
df=tryCatch({summary(x, silent=T)$coefficients[coefficient,]},
error = function(e) {
c(Estimate=NA, "Std. error"=NA, z=NA, p.value=NA)
})
names(df)[names(df)=="p.value"]<-"p_val_raw"
names(df)[names(df)=="Std. error"]<-"Std.Err"
names(df)[names(df)=="z"]<-"z-value"
}
}else if(method=="nbmm_adq"){
if(contrast_tf){
df=anova(x, L=rbind(contrast))$aovTab.L
colnames(df)[colnames(df)=="Pr(>|Chi|)"]<-"p_val_raw"
}else{
df=summary(x)$coef_table[coefficient,]
names(df)[names(df)=="p-value"]<-"p_val_raw"
}
}
df
})%>%dplyr::bind_rows()%>%
dplyr::mutate(Gene=gene_names[idx_converged_not_singular], p_val_adj=p.adjust(p_val_raw, method = p_adj_method))
if(method!="ptmixed"&method!="nbmm_adq"){
ret=ret%>%dplyr::select(Gene, Estimate, Std.Error, df, t.value,
p_val_raw, p_val_adj)
}else{
if(contrast_tf){
ret=ret%>%dplyr::select(Gene, Chisq, df, p_val_raw, p_val_adj)
}else ret=ret%>%dplyr::select(Gene, Estimate, Std.Err, "z-value", p_val_raw, p_val_adj)
}
}
rownames(ret) <- NULL
if(contrast_tf){
ret2<-list(contrast_mat=contrast,summary_table = data.frame(ret),
p_adj_method = p_adj_method)
}else{
ret2 <- list(coefficient = coef_out,
summary_table = data.frame(ret),
p_adj_method = p_adj_method)
}
if(method !="gee"&method!="ptmixed"){
genes_singular_fits <- as.character(gene_names[idx_singular])
genes_null=c(genes_singular_fits, as.character(gene_names[idx_not_converged]))%>%unique()
ret2$singular_fits = genes_singular_fits
}else genes_null=as.character(gene_names[idx_not_converged])
ret2$summary_table$Gene<-as.character(ret2$summary_table$Gene)
ret2$summary_table <- gtools::smartbind(ret2$summary_table, data.frame(Gene = genes_null))
}
ret2$summary_table<-ret2$summary_table[match(gene_names,
ret2$summary_table$Gene),]
if(sort_results){
ret2$summary_table <- ret2$summary_table %>%
dplyr::arrange(p_val_adj)
}
ret2$model_method=method
if(method!="ptmixed"|method!="nbmm_adq") ret2$df=df_name
rownames(ret2$summary_table)<-NULL
return(ret2)
}
########################################
#Calculate containment and residual df
########################################
calc_df<-function(model, df, method){
if(method=="lmm"|method=="nbmm_pl"|method=="nbmm_ml"){
#if nbmm_ml, fit lmm in order to get zmat and xmat
if(method=="nbmm_ml") model=lme4::lmer(formula = model$formula, data=model$data)
if(method=="lmm") model=model$fit
ids<-names(ranef(model))
#Mistake-not arequirement to have same number of measurements for each subject
#if(length(unique(table(model@frame[,ids])))!=1) stop("Must have the same number of measurements for each subject")
x_mat=matrix(getME(model, "X"), ncol =ncol(getME(model, "X")))
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(x_mat)-x_rank
}else if(df=="containment"){
z_mat<-matrix(getME(model, "Z"), ncol =ncol(getME(model, "Z")) )
xz_mat<-cbind(z_mat, x_mat)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model@frame)-xz_rank
}
}else if(method=="gee"){
if(length(unique(table(model$id)))!=1) stop("Must have the same number of measurements for each subject")
x_mat=model.matrix(model$formula, model$data)
if(df=="residual"){
x_rank=qr(x_mat)$rank
df_val=nrow(model$data)-x_rank
}else if(df=="containment"){
z_mat=model.matrix(~-1+as.factor(model$id))
xz_mat<-cbind(z_mat, model$model)
xz_rank<-qr(xz_mat)$rank
df_val=nrow(model$data)-xz_rank
}
}
return(df_val)
}
test=corrSeq_summary(fit, coefficient="group", df=NA)
View(test)
View(test[["summary_table"]])
?corrSeq_fit
library(corrRNASeq)
library(corrRNASeq)
library(corrRNASeq)
sample_sizes=c(3, 5, 10)
methods=c("nbmm_pl", "lmm", "rmrnaseq", "ptmixed", "nbmm_adq")
time_points=c(4)
time_points=c(4)
n_sim <- 10
sim_type="FDR"
contrasts=list(
c1=c(0,1,0,0,0,0,0,1), #Difference in group at final time point
c2=c(0,0,0,0,1,0,0,1), #Difference in first and last time in trt group
#Difference in group at any timepoint
c3=rbind(c(0, 1, 0, 0, 0, 0, 0, 0), #Difference in groups at time1
c(0, 1, 0, 0, 0, 1, 0, 0), #Difference in groups at time2
c(0, 1, 0, 0, 0, 0, 1, 0), #Difference in groups at time3
c(0, 1, 0, 0, 0, 0, 0, 1)  #Difference in groups at time4
),
# Difference between any timepoints in treatment group
c4=rbind(c(0, 0, 1,  0,  0,  1,  0,  0), #Difference btwn. time1 and time2 in trt.
c(0, 0, 0,  1,  0,  0,  1,  0), #Difference btwn. time1 and time3 in trt.
c(0, 0, 0,  0,  1,  0,  0,  1), #Difference btwn. time1 and time4 in trt.
c(0, 0, 1, -1,  0,  1, -1,  0), #Difference btwn. time2 and time3 in trt.
c(0, 0, 1,  0, -1,  1,  0, -1), #Difference btwn. time2 and time4 in trt.
c(0, 0, 0,  1, -1,  0,  1, -1)  #Difference btwn. time3 and time4 in trt.
),
# Are any of the interactions significant
c5=rbind(c(0, 0, 0,  0,  0,  1,  0, 0),
c(0, 0, 0,  0,  0,  0,  1, 0),
c(0, 0, 0,  0,  0,  0,  0, 1)
),
# Any Significant Coefficients
c6=rbind(c(0, 1, 0,  0,  0,  0,  0,  0),
c(0, 0, 1,  0,  0,  0,  0,  0),
c(0, 0, 0,  1,  0,  0,  0,  0),
c(0, 0, 0,  0,  1,  0, 0,  0),
c(0, 0, 0,  0,  0,  1,  0, 0),
c(0, 0, 0,  0,  0,  0,  1, 0),
c(0, 0, 0,  0,  0,  0,  0, 1)
)
)
param_mat <- expand.grid(n_sub_group = sample_sizes, methods=methods,
time_points=time_points)
param_mat
dim(param_mat)
