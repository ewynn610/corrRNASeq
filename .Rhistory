################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(form, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=quote(ids), ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")%>%paste(collapse = "+")
random=paste("~", random)%>%as.formula()
args<-list(formula=form_sub, data=quote(dat_sub), random=quote(random),
family = "nbinom",...)
method_call=glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
}
names(ret)<-gene_names
return(ret)
}
test<-seq_fit(form =  ~ group * time+(1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
method="lmm")
View(test)
lmerSeq.fit(form = ~ group * time + (1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
REML = T)
test<-lmerSeq.fit(form = ~ group * time + (1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
REML = T)
View(test)
test<-seq_fit(form =  ~ group * time+(1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
weights=rep(1, nrow(vst_expr)),
method="lmm")
View(test)
seq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
parallel = F,
cores = 2, ...
){
if(method=="lmm"){
ret=lmerSeq::lmerSeq.fit(formula = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
ret=lapply(ret, function(x) x$fit)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=quote(ids), ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")%>%paste(collapse = "+")
random=paste("~", random)%>%as.formula()
args<-list(formula=form_sub, data=quote(dat_sub), random=quote(random),
family = "nbinom",...)
method_call=glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
}
names(ret)<-gene_names
return(ret)
}
test<-seq_fit(formula =  ~ group * time+(1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
weights=rep(1, nrow(vst_expr)),
method="lmm")
?lmerSeq.fit
seq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
parallel = F,
cores = 2, ...
){
if(method=="lmm"){
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
ret=lapply(ret, function(x) x$fit)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=quote(ids), ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")%>%paste(collapse = "+")
random=paste("~", random)%>%as.formula()
args<-list(formula=form_sub, data=quote(dat_sub), random=quote(random),
family = "nbinom",...)
method_call=glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
}
names(ret)<-gene_names
return(ret)
}
data("expr_data")
vst_expr <- expr_example$vst_expr
sample_meta_data <- expr_example$sample_meta_data
##  Only including 10 genes in the expression matrix
vst_expr <- vst_expr[1:10, ]
##  Fit the Model
fit.lmerSeq <- lmerSeq.fit(form = ~ group * time + (1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
REML = T)
View(vst_expr)
View(test)
lmerSeq.fit <- function(form = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
weights = NULL, # Matrix of same dimension as expr_mat with gene-specific weights for each sample
REML = T, # Fit mixed models using REML or ML
parallel = F,
cores = 2
){
browser()
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(form)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = rownames(expr_mat)
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(form, expr ~ .)
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(lmerTest::lmer(formula = form_sub,
data = dat_sub,
REML = REML,
weights = weights[i, ]))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- list(fit = ret_sub, gene = gene_names[i])
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(lmerTest::lmer(formula = form_sub,
data = dat_sub,
REML = REML,
weights = weights[i, ]))
}, error = function(e) {
ret_sub2 <- NULL
})
ret2 <- list(fit = ret_sub, gene = gene_names[i])
})
}
names(ret) = gene_names
return(ret)
}
fit.lmerSeq <- lmerSeq.fit(form = ~ group * time + (1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
REML = T)
i=1
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
lmerTest::lmer(formula = form_sub,
data = dat_sub,
REML = REML,
weights = weights[i, ])
i=1
lmer(formula = form_sub,
data = dat_sub,
REML = REML,
weights = weights[i, ])
i
weights
weights[]
weights[1,]
lmer(formula = form_sub,
data = dat_sub,
REML = REML)
seq_fit <- function(formula = NULL, # Formula for fixed effects
expr_mat = NULL, # Matrix of transformed RNA-Seq counts where rows are genes and columns are samples
gene_names = NULL, # A vector of gene names (the length of the number of rows in the expression matrix).  If unspecified, rownames from the expression matrix will be used.
sample_data = NULL, # A data frame with sample meta data
method,
id,
parallel = F,
cores = 2, ...
){
if(method=="lmm"){
ret=lmerSeq::lmerSeq.fit(form = formula, expr_mat = expr_mat,
gene_names = gene_names,
sample_data = sample_data, parallel = parallel,
cores = cores,...)
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
ret=lapply(ret, function(x) x$fit)
}else{
############################################################################################################
#Error Messages for insufficient or inconsistent information
############################################################################################################
### Insufficient Information ###
if(is.null(expr_mat)==T ) {
stop("An expression matrix must be provided.")}
if(is.null(formula)==T ) {
stop("A formula must be provided.")}
if(is.null(sample_data)==T ) {
stop("sample_data is missing.")}
### Inconsistent information ###
if((ncol(expr_mat)==nrow(sample_data))==F ) {
stop("The expression matrix and sample data include differing numbers of samples.")}
if(is.null(gene_names)==F & (nrow(expr_mat)==length(gene_names))==F ) {
print("The expression matrix and gene_names indicate differing numbers of genes.
Row names of the expression matrix will be used as gene names.")
gene_names = rownames(expr_mat)
}
################################################################################################
# Calculate Default Values if none supplied
################################################################################################
# Gene Names
if(is.null(gene_names)){
if(is.null(rownames(expr_mat))==T){rownames(expr_mat)<-seq(1,nrow(expr_mat),1)}
gene_names = paste0("gene_", rownames(expr_mat))
}
############################################################################################################
# Begin Analysis
############################################################################################################
# Make sure expr_mat is a matrix
expr_mat <- as.matrix(expr_mat)
# Ensure that contrast, gene and fixed effect names are supplied as characters
gene_names <- as.character(gene_names)
form_sub <- update(formula, expr ~ .)
if(method=="gee"){
args<-list(formula=form_sub, data=quote(dat_sub), id=quote(ids), ...)
method_call=geeglm_small_samp
}else if(method=="nbmm_ml"){
random=paste("(", lme4::findbars(form_sub), ")")%>%paste(collapse = "+")
random=paste("~", random)%>%as.formula()
args<-list(formula=form_sub, data=quote(dat_sub), random=quote(random),
family = "nbinom",...)
method_call=glmmadmb
}else if(method=="nbmm_pl"){
args<-list(formula=form_sub, data=quote(dat_sub),...)
method_call=glmm_nb_lmer
}
if(parallel == F){
ret <- pbapply::pblapply(X = 1:nrow(expr_mat),
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
else{
ret <- parallel::mclapply(X = 1:nrow(expr_mat),
mc.silent = T,
mc.cores = cores,
FUN = function(i){
dat_sub <- cbind(sample_data, data.frame(expr = as.numeric(expr_mat[i, ])))
ret_sub <- tryCatch({
tmp1 <- suppressMessages(do.call(method_call, args))
}, error = function(e) {
ret_sub2 <- NA
})
ret2 <- ret_sub
})
}
}
names(ret)<-gene_names
return(ret)
}
test<-seq_fit(formula =  ~ group * time+(1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
method="lmm")
data("expr_data")
vst_expr <- expr_example$vst_expr
sample_meta_data <- expr_example$sample_meta_data
##  Only including 10 genes in the expression matrix
vst_expr <- vst_expr[1:10, ]
library(lmerSeq)
data("expr_data")
vst_expr <- expr_example$vst_expr
sample_meta_data <- expr_example$sample_meta_data
##  Only including 10 genes in the expression matrix
vst_expr <- vst_expr[1:10, ]
test<-seq_fit(formula =  ~ group * time+(1|ids),
expr_mat = vst_expr,
sample_data = sample_meta_data,
method="lmm")
View(test)
